<!DOCTYPE html>  <html lang="en">  
<head>  
<meta charset="UTF-8">  
<title>Beast Player</title>  
<meta name="viewport" content="width=device-width, initial-scale=1">  
<meta name="theme-color" content="#111">  <script src="jsmediatags.min.js"></script>  <script src="lucide.min.js"></script> 
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#111">
 <style>  
:root{  
  --bg:#050a0f;  
  --card:#0d151f;  
  --box:#091018;  
  --item:#162431;  
  --text:#d1e3f0;  
  --accent:#0091ea;  
}  
  
*{  
  box-sizing:border-box;  
  font-family:system-ui;  
  -webkit-tap-highlight-color:transparent;  
}  
  
body{  
  margin:0;  
  background:var(--bg);  
  color:var(--text);  
}  
body.light{  
  --bg:#f2f5f8;  
  --card:#ffffff;  
  --item:#e8eef4;  
  --text:#111;  
  --accent:#0066cc;  
}  
/* Disable text selection for app UI */
body, 
button, 
.song, 
header, 
footer, 
.mini, 
.controls {
  -webkit-user-select: none;
  user-select: none;
}

/* Prevent blue tap highlight on Android */
* {
  -webkit-tap-highlight-color: transparent;
}
input, textarea, select {
  -webkit-user-select: text;
  user-select: text;
}
  
header{  
  padding:18px 16px 10px;  
  text-align:center;  
  font-size:26px;  
  font-weight:800;  
  letter-spacing:.5px;  
  color:var(--accent);  
}  
  
/* ---------- TOP CONTROLS ---------- */  
.controls{  
  display:flex;  
  gap:10px;  
  padding:14px;  
  flex-wrap:wrap;  
  justify-content:center;  
}  
  
button,select{  
  background:var(--item);  
  border:none;  
  color:var(--text);  
  padding:12px 14px;  
  border-radius:24px;  
  display:flex;  
  align-items:center;  
  justify-content:center;  
  box-shadow:0 8px 20px rgba(0,0,0,.35);  
  transition:.25s;  
}  
  
button:active{  
  transform:scale(.95);  
}  
  
button i{  
  width:18px;  
  height:18px;  
}  
  
select{  
  appearance:none;  
}  
  
/* ---------- PLAYLIST ---------- */  
#list{  
  padding:14px;  
  padding-bottom:180px; /* ðŸ‘ˆ space for mini + footer */  
  height:calc(100vh - 200px);  
  overflow-y:auto;  
}  
  
.song{  
  display:flex;  
  justify-content:space-between;  
  align-items:center;  
  padding:16px;  
  margin-bottom:12px;  
  border-radius:18px;  
  background:var(--item);  
  box-shadow:0 10px 25px rgba(0,0,0,.4);  
  cursor:pointer;  
  transition:.3s;  
}  
  
.song:active{  
  transform:scale(.97);  
}  
  
.song.active{  
  background:var(--accent);  
  color:#fff;  
  box-shadow:0 0 30px rgba(0,145,234,.6);  
}  
  
.song-actions{  
  display:flex;  
  gap:8px;  
}  
  
/* ---------- FOOTER PLAYER ---------- */  
footer{  
  position:fixed;  
  bottom:0;  
  left:0;  
  right:0;  
  background:var(--card);  
  padding:14px 16px 22px;  
  box-shadow:0 -10px 20px rgba(0,0,0,.6);  
  z-index:15;  
}  
  
input[type=range]{  
  width:100%;  
  height:4px;  
  accent-color:var(--accent);  
  margin-bottom:14px;  
}  
  
footer button{  
  background:var(--item);  
}  
  
/* ---------- MINI PLAYER ---------- */  
.mini{  
  position:fixed;  
  bottom:110px;  
  left:12px;  
  right:12px;  
  height:64px;  
  background:var(--card);  
  border-radius:22px;  
  display:flex;  
  align-items:center;  
  gap:12px;  
  padding:10px 16px;  
  box-shadow:0 15px 40px rgba(0,0,0,.6);  
  z-index:20;  
}  
  
.mini.hidden{  
  display:none;  
}  
  
.mini img{  
  width:44px;  
  height:44px;  
  border-radius:12px;  
  object-fit:cover;  
}  
  
.mini-info{  
  flex:1;  
  overflow:hidden;  
}  
  
#miniTitle{  
  white-space:nowrap;  
  overflow:hidden;  
  text-overflow:ellipsis;  
  font-weight:600;  
}  
.mini{  
  bottom:120px;  
}  
footer{  
  z-index:20;  
}  
  
.mini{  
  z-index:30;  
}  
.song.removing{  
  animation: shrinkFade .25s ease forwards;  
}  
  
@keyframes shrinkFade{  
  to{  
    opacity:0;  
    transform:scale(.92);  
    height:0;  
    margin-bottom:0;  
    padding-top:0;  
    padding-bottom:0;  
  }  
}  
.topbar{  
  display:flex;  
  align-items:center;  
  justify-content:center;  
  position:relative;  
  padding:18px 16px;  
  font-size:26px;  
  font-weight:800;  
  color:var(--accent);  
}  
  
.menu-btn{  
  position:absolute;  
  left:16px;  
  background:var(--item);  
}  
.menu{  
  position:absolute;  
  top:70px;  
  left:12px;  
  background:var(--card);  
  border-radius:16px;  
  padding:10px;  
  display:flex;  
  flex-direction:column;  
  gap:6px;  
  box-shadow:0 15px 40px rgba(0,0,0,.6);  
  z-index:50;  
}  
  
.menu button{  
  display:flex;  
  align-items:center;  
  gap:10px;  
  padding:10px 14px;  
}  
  
.menu.hidden{  
  display:none;  
}  
button.active{  
  background: var(--accent);  
  color: #fff;  
}  
#h{  
border-left:6px solid var(--accent);  
padding-left:10px;  
font-size:30px  
}  
.blueb{  
background-color:var(--accent); 
box-shadow:
    0 0 10px color-mix(in srgb, var(--accent) 60%, transparent),
    0 0 22px color-mix(in srgb, var(--accent) 35%, transparent); 
}  
#dele{  
border:0.5px solid #FF0E00;  
color:#FF0E00  
}  
/* normal button */  
#themeToggle {  
  background: transparent;  
}  
  
/* ACTIVE = dark mode ON */  
#themeToggle.active {  
  background: #2563eb; /* blue */  
  color: #fff;  
}  
/* ---------- SONG ACTION BUTTONS ---------- */
.song-actions button{
  background: var(--box);
  border: none;
  color: var(--text);
  padding: 8px;
  border-radius: 14px;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 6px 16px rgba(0,0,0,.25);
  transition: .2s ease;
}

.song-actions button:active{
  transform: scale(.92);
}

/* MOVE BUTTON */
.song-actions .move-btn{
  color: var(--accent);
}

/* DELETE BUTTON */
.song-actions .delete-btn{
  color: #ff3b30;
}

/* Light mode fix */
body.light .song-actions button{
  background: #e6ecf2;
  box-shadow: 0 4px 12px rgba(0,0,0,.15);
}

/* Hover feedback (desktop users) */
.song-actions button:hover{
  opacity: .85;
}
.sleep-timer {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px;
  border-radius: 12px;
  background: var(--card);
}

.sleep-timer input {
  width: 70px;
  text-align: center;
  background: transparent;
  color: inherit;
  border: 1px solid rgba(255,255,255,.2);
  border-radius: 8px;
  padding: 4px;
  font-size: 14px;
}
#toast {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%) translateY(20px);
  background: rgba(0,0,0,0.85);
  color: #fff;
  padding: 10px 16px;
  border-radius: 12px;
  font-size: 14px;
  opacity: 0;
  pointer-events: none;
  transition: 0.3s ease;
  z-index: 9999;
}

#toast.show {
  opacity: 1;
  transform: translateX(-50%) translateY(0);
}
*{
transition:all ease 0.3s
}
.song.dragging{
  opacity: .5;
  transform: scale(.96);
}
#shuffleBtn,#repeatBtn, #sf, #rp{
width:40px; height:40px;
}
</style>  </head>
<script>  
if ("serviceWorker" in navigator) {  
  navigator.serviceWorker.register("./service-worker.js");
}  
</script>  
  <body>  <header class="topbar">  
  <button class="menu-btn" onclick="toggleMenu()">  
    <i data-lucide="menu"></i>  
  </button>  
  <span id="h">Beast Player</span>  
</header>  
<div id="menu" class="menu hidden">  
  <button id="themeToggle">  
  <i data-lucide="moon"></i>  
  <span>Dark mode</span>  
</button>    <button onclick="showAbout()">  
    <i data-lucide="info"></i>  
    <span>About</span>  
  </button>  
  <button onclick="openConverter()">  
  <i data-lucide="arrow-left-right"></i>  
  <span>Go to Converter</span>  
</button>  
</div>  <div id="miniPlayer" class="mini hidden">  
  <img id="miniArt">  
  <div class="mini-info">  
    <div id="miniTitle"></div>  
  </div>  
</div>  <div class="controls">  
    <button onclick="pickFiles()", class="blueb"><i data-lucide="plus"></i></button>  
    <button onclick="createPlaylist()", class="blueb"><i data-lucide="folder-plus"></i></button>  
    <select id="playlistSelect" onchange="loadPlaylist(this.value)"></select>  
    <button onclick="deletePlaylist()", id="dele"><i data-lucide="trash-2"></i></button>  

    
    <button onclick="openSleepTimer()">
  <i data-lucide="timer"></i>
  <span>Sleep timer</span>
</button>
</div>
<div id="sleepTimer" class="menu hidden" style="right:12px; left:auto; width:220px", align="center">

  <div style="display:flex;justify-content:space-between;align-items:center">
  <span style="font-size:13px;opacity:.8">Sleep timer</span>

  <button onclick="closeSleepTimer()"
          style="background:transparent;padding:6px">
    <i data-lucide="x"></i>
  </button>
</div>

  <!-- Countdown -->
  <div id="sleepCountdown"
       style="font-size:22px;font-weight:700;text-align:center;margin:8px 0">
    00:00
  </div>

  <!-- Progress ring -->
  <svg width="120" height="120" viewBox="0 0 120 120"
       style="display:block;margin:0 auto 8px;transform:rotate(-90deg)">
    <circle cx="60" cy="60" r="52"
      stroke="rgba(255,255,255,.15)"
      stroke-width="8"
      fill="none"/>
    <circle id="sleepProgress"
      cx="60" cy="60" r="52"
      stroke="var(--accent)"
      stroke-width="8"
      stroke-linecap="round"
      fill="none"
      stroke-dasharray="326"
      stroke-dashoffset="326"/>
  </svg>

  <label style="font-size:12px;opacity:.8">Minutes (1-60)</label>
  <input id="sleepMinutes" type="number" min="1" max="60" value="10"
    style="padding:8px;border-radius:10px;border:none;background:var(--item);color:var(--text)">

  <button onclick="startSleepTimer()">
    <i data-lucide="play"></i>
    <span>Start</span>
  </button>

  <button onclick="cancelSleepTimer()" id="dele">
    <i data-lucide="x"></i>
    <span>Cancel</span>
  </button>
</div>
  <div id="list"></div>  <footer>  
<div style="display:flex;justify-content:space-between;font-size:13px;opacity:.8">  
  <span id="curTime">0:00</span>  
  <span id="durTime">0:00</span>  
</div>  <input type="range" id="seek">  <div class="player-buttons" style="display:flex;gap:14px;justify-content:center">  
<button id="repeatBtn" onclick="toggleRepeat()"><i data-lucide="repeat",  id="rp"></i></button>  
    <button onclick="prev()"><i data-lucide="skip-back"></i></button>  
    <button onclick="toggle()" id="playBtn">
  <i data-lucide="play"></i>
</button>
    
    <button onclick="next()"><i data-lucide="skip-forward"></i></button>  
    <button id="shuffleBtn", onclick="toggleShuffle()"><i data-lucide="shuffle", id="sf"></i></button>  
</div>
<div id="toast"></div>
</footer>  <audio id="audio"></audio>


<script>  
let db;  
let songs = {};  
let playlists = {};  
let activePlaylist = [];  
let activePlaylistId = "all";  
let currentIndex = -1;  
let isSeeking = false;  
let sleepEndTime = 0;
let sleepTotal = 0;
let sleepTimer = null;   //  THIS WAS MISSING

const sleepCountdown = document.getElementById("sleepCountdown");
const sleepProgress = document.getElementById("sleepProgress");
const sleepInput = document.getElementById("sleepMinutes");
  
let shuffle = false;  
let repeatMode = 0;  
// 0 = OFF  
// 1 = REPEAT ALL  
// 2 = REPEAT ONE  
  
const audio = document.getElementById("audio");  
const list = document.getElementById("list");  
const savedSleep = +localStorage.getItem("sleepEnd");

if (savedSleep && savedSleep > Date.now()){
  sleepEndTime = savedSleep;
  sleepTotal = savedSleep - Date.now();
  updateSleepUI();
  sleepTimer = setInterval(updateSleepUI, 1000);
}
const seek = document.getElementById("seek");  
seek.addEventListener("input", () => {  
  isSeeking = true;  
  audio.currentTime = seek.value;  
});  
  
seek.addEventListener("change", () => {  
  isSeeking = false;  
});  
const select = document.getElementById("playlistSelect");  
function haptic(ms = 20){  
  if (navigator.vibrate) navigator.vibrate(ms);  
}  
  
audio.onplay = audio.onpause = () => lucide.createIcons();  
  
/* ---------- DATABASE ---------- */  
const req = indexedDB.open("BeastPlayerDB",1);  
req.onupgradeneeded = e=>{  
    const d=e.target.result;  
    d.createObjectStore("songs",{keyPath:"id"});  
    d.createObjectStore("playlists",{keyPath:"id"});  
};  
req.onsuccess = e=>{  
    db=e.target.result;  
    init();  
};  
  
function init(){  
    const tx=db.transaction("playlists","readwrite");  
    const st=tx.objectStore("playlists");  
    st.get("all").onsuccess=e=>{  
        if(!e.target.result){  
            st.put({id:"all",name:"All Songs",songIds:[]});  
        }  
    };  
    tx.oncomplete=loadAll;  
}  
  
function loadAll(){ loadSongs(loadPlaylists); }  
  
function loadSongs(cb){  
    songs={};  
    const tx=db.transaction("songs");  
    tx.objectStore("songs").openCursor().onsuccess=e=>{  
        const c=e.target.result;  
        if(c){ songs[c.value.id]=c.value; c.continue(); }  
        else cb();  
    };  
}  
  
function loadPlaylists(){  
    playlists={};  
    select.innerHTML="";  
    const tx=db.transaction("playlists");  
    tx.objectStore("playlists").openCursor().onsuccess=e=>{  
        const c=e.target.result;  
        if(c){  
            playlists[c.value.id]=c.value;  
            const o=document.createElement("option");  
            o.value=c.value.id;  
            o.textContent=c.value.name;  
            select.appendChild(o);  
            c.continue();  
        }else{  
            select.value=activePlaylistId;  
            loadPlaylist(activePlaylistId);  
        }  
    };  
}  
  
function loadPlaylist(id){  
    activePlaylistId=id;  
    const p=playlists[id];  
    if(!p) return;  
    activePlaylist=p.songIds.map(i=>songs[i]).filter(Boolean);  
    currentIndex=-1;  
    render();  
}  
  
/* ---------- UI ---------- */  
function render(){  
  list.innerHTML="";  

  activePlaylist.forEach((s,i)=>{  
    const d = document.createElement("div");
d.draggable = true;
    d.className="song"+(i===currentIndex?" active":"");  
    d.onclick=()=>play(i);  
d.ondragstart = e => {
  e.dataTransfer.setData("text/plain", i);
  d.classList.add("dragging");
};

d.ondragend = () => {
  d.classList.remove("dragging");
};

d.ondragover = e => {
  e.preventDefault();
};

d.ondrop = e => {
  e.preventDefault();

  const from = +e.dataTransfer.getData("text/plain");
  const to = i;

  if (from === to) return;

  const song = activePlaylist.splice(from, 1)[0];
  activePlaylist.splice(to, 0, song);

  savePlaylistOrder();
  render();
};
    const t=document.createElement("span");  
    t.textContent=s.name;  

    const a=document.createElement("div");  
    a.className="song-actions";  

    /* REMOVE FROM PLAYLIST (only if not ALL) */
    if(activePlaylistId!=="all"){  
      const r=document.createElement("button");  
      r.innerHTML='<i data-lucide="x"></i>';  
      r.onclick=e=>{  
        e.stopPropagation();  
        haptic(20);  
        removeFromPlaylist(s.id);  
      };  
      a.appendChild(r);  
    }

    /* MOVE TO PLAYLIST */
    const move=document.createElement("button");
    move.innerHTML='<i data-lucide="folder-input"></i>';
    move.onclick=e=>{
      e.stopPropagation();
      haptic(20);

      const names = Object.values(playlists)
        .filter(p => p.id !== activePlaylistId)
        .map(p => p.name);

      if(!names.length){
        alert("No other playlist available");
        return;
      }

      const targetName = prompt(
        "Move to which playlist?\n\n" + names.join("\n")
      );
      if(!targetName) return;

      const target = Object.values(playlists)
        .find(p => p.name === targetName);

      if(!target) return;

      if(!target.songIds.includes(s.id)){
        const tx=db.transaction("playlists","readwrite");
        target.songIds.push(s.id);
        tx.objectStore("playlists").put(target);
        tx.oncomplete=loadAll;
      }
    };
    a.appendChild(move);
    /* DOWNLOAD MP3 (Only in ALL songs playlist) */
if(activePlaylistId === "all"){
  const down=document.createElement("button");
  down.innerHTML='<i data-lucide="download"></i>';

  down.onclick = e => {
    e.stopPropagation();
    haptic(20);
    downloadSong(s);
  };

  a.appendChild(down);
}
    /* DELETE EVERYWHERE */
    const del=document.createElement("button");  
    del.innerHTML='<i data-lucide="trash"></i>';  
    del.onclick = e => {
  e.stopPropagation();
  

  const ok = confirm(`Delete "${s.name}"?`);
  if (!ok) return;

  d.classList.add("removing");
  setTimeout(() => deleteSongEverywhere(s.id), 250);
};
    a.appendChild(del);  

    d.append(t,a);  
    list.appendChild(d);  
  });  

  lucide.createIcons();  
}
/* ---------- PLAYER ---------- */  
function play(i){  
haptic(20);  
    if(!activePlaylist[i]) return;  
  
    currentIndex=i;  
    audio.src=URL.createObjectURL(activePlaylist[i].blob);  
    audio.play();  
  
    miniPlayer.classList.remove("hidden");  
  
    updateMedia();  
    render();  
}  
  
function toggle(){
  haptic(30);
  audio.paused ? audio.play() : audio.pause();
  updatePlayIcon();
}
  
  
function prev(){  
    if(audio.currentTime>5) audio.currentTime=0;  
    else if(currentIndex>0) play(currentIndex-1);  
}  
  
audio.ontimeupdate = () => {  
    if (!isSeeking) {  
        seek.max = audio.duration || 0;  
        seek.value = audio.currentTime || 0;  
    }  
  
    curTime.textContent = formatTime(audio.currentTime);  
    durTime.textContent = formatTime(audio.duration);  
};  
  
function next(){

  if (activePlaylist.length === 0) return;

  // If nothing was playing, don't continue
  if (currentIndex === -1) return;

  // Repeat ONE
  if (repeatMode === 2) {
    play(currentIndex);
    return;
  }

  // Shuffle
  if (shuffle) {
    let nextIndex;
    do {
      nextIndex = Math.floor(Math.random() * activePlaylist.length);
    } while (activePlaylist.length > 1 && nextIndex === currentIndex);

    play(nextIndex);
    return;
  }

  // Normal next
  if (currentIndex < activePlaylist.length - 1) {
    play(currentIndex + 1);
  } 
  else {
    if (repeatMode === 1) {
      play(0); // repeat all
    } 
    else {
      // STOP cleanly
      currentIndex = -1;
      updatePlayIcon();
    }
  }
}
  
/* ---------- CONTROLS ---------- */  
function toggleShuffle(){  
haptic(30);  
    shuffle=!shuffle;  
    updateControlStates();  
}  
function toggleRepeat(){  
  haptic(30);  
  repeatMode = (repeatMode + 1) % 3;  
  updateControlStates();  
}  
function updateControlStates(){  
  shuffleBtn.classList.toggle("active", shuffle);  
  
  repeatBtn.classList.toggle("active", repeatMode !== 0);  
  
  // optional icon change  
  const icon =  
    repeatMode === 2 ? "repeat-1" : "repeat";  
  repeatBtn.innerHTML = `<i data-lucide="${icon}"></i>`;  
  lucide.createIcons();  
}  
  
/* ---------- FILE ADD ---------- */  
function pickFiles(){  
    const input=document.createElement("input");  
    input.type="file";  
    input.multiple=true;  
    input.accept="audio/*,video/mp4";  
    input.onchange=()=>{  
        const tx=db.transaction(["songs","playlists"],"readwrite");  
        const s=tx.objectStore("songs");  
        const p=tx.objectStore("playlists");  
        p.get("all").onsuccess=e=>{  
            const all=e.target.result;  
            const target=playlists[activePlaylistId];  
            [...input.files].forEach(f=>{  
                const id=crypto.randomUUID();  
                s.put({id,name:f.name,blob:f});  
                all.songIds.push(id);  
                if(activePlaylistId!=="all") target.songIds.push(id);  
            });  
            p.put(all);  
            if(activePlaylistId!=="all") p.put(target);  
        };  
        tx.oncomplete=loadAll;  
    };  
    input.click();  
}  
  
/* ---------- DELETE ---------- */  
function removeFromPlaylist(id){  
haptic(30);  
    const tx=db.transaction("playlists","readwrite");  
    tx.objectStore("playlists").get(activePlaylistId).onsuccess=e=>{  
        const p=e.target.result;  
        p.songIds=p.songIds.filter(x=>x!==id);  
        tx.objectStore("playlists").put(p);  
    };  
    tx.oncomplete=loadAll;  
}  
  
function deleteSongEverywhere(id){  
haptic(30);  
    const tx=db.transaction(["songs","playlists"],"readwrite");  
    tx.objectStore("songs").delete(id);  
    tx.objectStore("playlists").openCursor().onsuccess=e=>{  
        const c=e.target.result;  
        if(c){  
            c.value.songIds=c.value.songIds.filter(x=>x!==id);  
            e.target.source.put(c.value);  
            c.continue();  
        }  
    };  
    tx.oncomplete=loadAll;  
}  
  
function deletePlaylist(){  
    // CASE 1: ALL SONGS â†’ delete ALL SONGS (not playlist)  
    haptic(30);  
    if (activePlaylistId === "all") {  
        if (!confirm("Delete ALL songs? This cannot be undone.")) return;  
  
        audio.pause();  
        audio.src = "";  
        currentIndex = -1;  
  
        const tx = db.transaction(["songs","playlists"],"readwrite");  
  
        // Clear all songs  
        tx.objectStore("songs").clear();  
  
        // Reset all playlists  
        const pStore = tx.objectStore("playlists");  
        pStore.openCursor().onsuccess = e => {  
            const c = e.target.result;  
            if (c) {  
                if (c.value.id === "all") {  
                    c.value.songIds = [];  
                    pStore.put(c.value);  
                } else {  
                    pStore.delete(c.value.id);  
                }  
                c.continue();  
            }  
        };  
  
        tx.oncomplete = () => {  
            document.getElementById("miniPlayer").classList.add("hidden");  
            loadAll();  
        };  
  
        return;  
    }  
  
    // CASE 2: NORMAL PLAYLIST â†’ delete playlist  
    if (!confirm("Delete this playlist?")) return;  
  
    const tx = db.transaction("playlists","readwrite");  
    tx.objectStore("playlists").delete(activePlaylistId);  
    activePlaylistId = "all";  
    tx.oncomplete = loadAll;  
}  
  
function createPlaylist(){  
haptic(30);  
    const n=prompt("Playlist name?");  
    if(!n) return;  
    const tx=db.transaction("playlists","readwrite");  
    tx.objectStore("playlists").put({id:crypto.randomUUID(),name:n,songIds:[]});  
    tx.oncomplete=loadPlaylists;  
}  
  
/* ---------- MEDIA SESSION ---------- */  
async function updateMedia(){  
    if(!navigator.mediaSession||currentIndex<0) return;  
    const song=activePlaylist[currentIndex];  
    let art=await getArtwork(song.blob) || generateFallbackArtwork(song.name);  
  
    miniArt.src=art;  
    miniTitle.textContent=song.name;  
  
    navigator.mediaSession.metadata=new MediaMetadata({  
        title:song.name,  
        artist:"Beast Player",  
        artwork:[{src:art,sizes:"512x512",type:"image/png"}]  
    });  
  
    navigator.mediaSession.setActionHandler("play",()=>audio.play());  
    navigator.mediaSession.setActionHandler("pause",()=>audio.pause());  
    navigator.mediaSession.setActionHandler("nexttrack",next);  
    navigator.mediaSession.setActionHandler("previoustrack",prev);  
}  
  
function getArtwork(blob){  
    return new Promise(res=>{  
        jsmediatags.read(blob,{  
            onSuccess:t=>{  
                const p=t.tags.picture;  
                if(!p) return res(null);  
                res(URL.createObjectURL(new Blob([new Uint8Array(p.data)],{type:p.format})));  
            },  
            onError:()=>res(null)  
        });  
    });  
}  
  
function generateFallbackArtwork(t){  
    const c=document.createElement("canvas");  
    c.width=c.height=512;  
    const g=c.getContext("2d");  
    const h=Math.random()*360;  
    const grd=g.createLinearGradient(0,0,512,512);  
    grd.addColorStop(0,`hsl(${h},70%,45%)`);  
    grd.addColorStop(1,`hsl(${(h+90)%360},70%,35%)`);  
    g.fillStyle=grd;g.fillRect(0,0,512,512);  
    g.fillStyle="#fff";g.font="bold 48px system-ui";  
    g.textAlign="center";  
    g.fillText(t.slice(0,14),256,280);  
    return c.toDataURL();  
}  
  
lucide.createIcons();  
updateControlStates();  
function toggleMenu(){  
  haptic(20);  
  menu.classList.toggle("hidden");  
}  
const themeToggle = document.getElementById("themeToggle");

function applyTheme(isDark){
  document.body.classList.toggle("light", !isDark);
  themeToggle.classList.toggle("active", isDark);
  localStorage.setItem("theme", isDark ? "dark" : "light");
}

function toggleDark(){
  haptic(20);
  const isCurrentlyDark = !document.body.classList.contains("light");
  applyTheme(!isCurrentlyDark);
}

// Load saved theme
applyTheme(localStorage.getItem("theme") === "dark");

// Attach click event
themeToggle.addEventListener("click", toggleDark);

function toggleDark(){
  haptic(20);
  // Check current dark mode by whether body is light
  const isCurrentlyDark = !document.body.classList.contains("light");
  applyTheme(!isCurrentlyDark); // toggle!
}

// Load saved theme on startup
applyTheme(localStorage.getItem("theme") === "dark");
  

function showAbout(){  
  haptic(20);  
  alert(  
    "Beast Player\n\n" +  
    "Offline music player\n" +  
    "Made by a music artist Beast_Beats"  
  );  
}  
function openConverter(){  
  haptic(20);  
  window.location.href = "https://beast-beats.github.io/Beast_Convertor/";  
}  
function formatTime(sec){  
  if (!sec || isNaN(sec)) return "0:00";  
  const m = Math.floor(sec / 60);  
  const s = Math.floor(sec % 60).toString().padStart(2,"0");  
  return `${m}:${s}`;  
}  
function downloadSong(song){

  if(!song || !song.blob){
    toast("File not available");
    return;
  }

  // Use original filename exactly as uploaded
  const fileName = song.name;

  const url = URL.createObjectURL(song.blob);

  const a = document.createElement("a");
  a.href = url;
  a.download = fileName; // no extension modification
  document.body.appendChild(a);
  a.click();
  a.remove();

  // Clean memory properly
  setTimeout(() => {
    URL.revokeObjectURL(url);
  }, 1000);

  toast("Downloaded " + fileName);
}
</script>
<script>
if ("mediaSession" in navigator) {
  navigator.mediaSession.setActionHandler("nexttrack", () => {
    if (shuffle) {
      play(Math.floor(Math.random() * activePlaylist.length));
    } else if (currentIndex < activePlaylist.length - 1) {
      play(currentIndex + 1);
    } else if (repeatMode === 1) {
      play(0); // repeat all
    }
  });

  navigator.mediaSession.setActionHandler("previoustrack", () => {
    if (audio.currentTime > 5) {
      audio.currentTime = 0;
    } else if (currentIndex > 0) {
      play(currentIndex - 1);
    }
  });
}
function moveSongToPlaylist(songId){
  const names = Object.values(playlists)
    .filter(p => p.id !== "all")
    .map(p => `${p.id}:${p.name}`);

  if (!names.length) {
    alert("No playlists available");
    return;
  }

  const choice = prompt(
    "Move to playlist:\n\n" +
    names.map((n,i)=>`${i+1}. ${n.split(":")[1]}`).join("\n")
  );

  if (!choice) return;

  const index = parseInt(choice) - 1;
  if (isNaN(index) || index < 0 || index >= names.length) return;

  const targetId = names[index].split(":")[0];

  const tx = db.transaction("playlists","readwrite");
  const store = tx.objectStore("playlists");

  store.get(targetId).onsuccess = e => {
    const p = e.target.result;
    if (!p.songIds.includes(songId)) {
      p.songIds.push(songId);
      store.put(p);
    }
  };

  // if currently inside a normal playlist  remove from it
  if (activePlaylistId !== "all") {
    store.get(activePlaylistId).onsuccess = e => {
      const p = e.target.result;
      p.songIds = p.songIds.filter(id => id !== songId);
      store.put(p);
    };
  }

  tx.oncomplete = loadAll;
}
function openSleepTimer(){
  haptic(20);
  document.getElementById("menu")?.classList.add("hidden");
  document.getElementById("sleepTimer").classList.toggle("hidden");
}

function startSleepTimer(){
  const min = Math.max(1, Math.min(60, +sleepInput.value || 0));

  clearInterval(sleepTimer);

  sleepTotal = min * 60 * 1000;
  sleepEndTime = Date.now() + sleepTotal;
  localStorage.setItem("sleepEnd", sleepEndTime);

  updateSleepUI();
  sleepTimer = setInterval(updateSleepUI, 1000);

  toast(`Sleep timer set for ${min} min`);
}

function cancelSleepTimer(){
  clearInterval(sleepTimer);
  sleepTimer = null;

  sleepEndTime = 0;
  sleepTotal = 0;
  localStorage.removeItem("sleepEnd");

  sleepCountdown.textContent = "00:00";
  sleepProgress.style.strokeDashoffset = 326;

  toast("Sleep timer cancelled");
}

function updateSleepUI(){
  const remaining = sleepEndTime - Date.now();

  if (remaining <= 0){
    clearInterval(sleepTimer);
    sleepTimer = null;
    localStorage.removeItem("sleepEnd");

    audio.pause();
    toast("Sleep timer ended ");
    return;
  }

  const sec = Math.floor(remaining / 1000);
  const m = String(Math.floor(sec / 60)).padStart(2, "0");
  const s = String(sec % 60).padStart(2, "0");

  sleepCountdown.textContent = `${m}:${s}`;

  const progress = remaining / sleepTotal;
  sleepProgress.style.strokeDashoffset = 326 * (1 - progress);
}

function toast(msg){
  const t = document.getElementById("toast");
  t.textContent = msg;
  t.classList.add("show");
  setTimeout(() => t.classList.remove("show"), 2000);
}
function closeSleepTimer(){
  haptic(15);
  document.getElementById("sleepTimer").classList.add("hidden");
}
const playBtn = document.getElementById("playBtn");

function updatePlayIcon(){
  playBtn.innerHTML = `
    <i data-lucide="${audio.paused ? "play" : "pause"}"></i>
  `;
  lucide.createIcons();
}
audio.onplay  = updatePlayIcon;
audio.onpause = updatePlayIcon;
audio.onended = () => {
  next();
  updatePlayIcon();
};
function savePlaylistOrder(){
  if (activePlaylistId === "all") return;

  const tx = db.transaction("playlists", "readwrite");
  const store = tx.objectStore("playlists");

  store.get(activePlaylistId).onsuccess = e => {
    const p = e.target.result;
    p.songIds = activePlaylist.map(s => s.id);
    store.put(p);
  };
  
}
</script>
  </body>  
</html>