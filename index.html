<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Beast Player</title>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<meta name="theme-color" content="#060b14">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="manifest" href="manifest.json">
<script src="jsmediatags.min.js"></script>
<script src="lucide.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Syne:wght@400;700;800&family=DM+Sans:ital,opsz,wght@0,9..40,300;0,9..40,500;1,9..40,300&display=swap" rel="stylesheet">

<style>
/* ============================================================
   TOKENS & RESET
============================================================ */
:root{
  --bg:#060b14;
  --surface:#0c1625;
  --card:#111e30;
  --item:#182840;
  --border:rgba(255,255,255,.07);
  --text:#c8ddf0;
  --muted:#5b7a99;
  --accent:#00b4ff;
  --accent2:#7c3aed;
  --danger:#ff3b5c;
  --glow:rgba(0,180,255,.35);
  --glow2:rgba(124,58,237,.35);
  --font-head:'Syne',sans-serif;
  --font-body:'DM Sans',sans-serif;
  --r:20px;
  --r-sm:14px;
  --safe-bottom:env(safe-area-inset-bottom,0px);
}
body.light{
  --bg:#eef2f7;
  --surface:#f8fafc;
  --card:#ffffff;
  --item:#e4ecf5;
  --border:rgba(0,0,0,.08);
  --text:#0d1b2a;
  --muted:#7a96b0;
  --accent:#0077cc;
  --glow:rgba(0,119,204,.2);
}
*{box-sizing:border-box;margin:0;padding:0;
  -webkit-tap-highlight-color:transparent;
  -webkit-user-select:none;user-select:none;}
input,textarea{-webkit-user-select:text;user-select:text;}
html,body{height:100%;overflow:hidden;}
body{
  font-family:var(--font-body);
  background:var(--bg);
  color:var(--text);
  display:flex;
  flex-direction:column;
  position:relative;
  overscroll-behavior:none;
}

/* ── scrollbar ── */
::-webkit-scrollbar{width:3px;}
::-webkit-scrollbar-track{background:transparent;}
::-webkit-scrollbar-thumb{background:var(--item);border-radius:99px;}

/* ============================================================
   BACKGROUND BLOB
============================================================ */
.bg-blob{
  position:fixed;inset:0;pointer-events:none;z-index:0;overflow:hidden;
}
.bg-blob::before,.bg-blob::after{
  content:'';position:absolute;border-radius:50%;filter:blur(80px);opacity:.18;
  animation:blobMove 8s ease-in-out infinite alternate;
}
.bg-blob::before{
  width:400px;height:400px;background:var(--accent);top:-100px;left:-80px;
}
.bg-blob::after{
  width:350px;height:350px;background:var(--accent2);bottom:-80px;right:-60px;
  animation-delay:-4s;
}
@keyframes blobMove{
  0%{transform:translate(0,0) scale(1);}
  100%{transform:translate(40px,30px) scale(1.15);}
}

/* ============================================================
   TOP BAR
============================================================ */
.topbar{
  position:relative;z-index:40;
  display:flex;align-items:center;justify-content:space-between;
  padding:max(16px,env(safe-area-inset-top)) 16px 12px;
  background:rgba(6,11,20,.7);
  backdrop-filter:blur(20px);
  -webkit-backdrop-filter:blur(20px);
  border-bottom:1px solid var(--border);
}
.brand{
  font-family:var(--font-head);font-size:22px;font-weight:800;
  background:linear-gradient(135deg,var(--accent),var(--accent2));
  -webkit-background-clip:text;background-clip:text;
  -webkit-text-fill-color:transparent;
  letter-spacing:-.5px;
}
.topbar-actions{display:flex;gap:8px;align-items:center;}

/* ============================================================
   BUTTONS BASE
============================================================ */
button{
  border:none;cursor:pointer;
  font-family:var(--font-body);
  display:inline-flex;align-items:center;justify-content:center;gap:6px;
  transition:transform .15s,opacity .15s,background .2s,box-shadow .2s;
}
button:active{transform:scale(.93);}
.icon-btn{
  width:42px;height:42px;border-radius:50%;
  background:var(--item);color:var(--text);
  box-shadow:0 4px 14px rgba(0,0,0,.3);
}
.icon-btn.glow{
  background:var(--accent);color:#fff;
  box-shadow:0 0 0 0 var(--glow),0 8px 20px rgba(0,0,0,.4);
  animation:pulseBtn 2.5s ease infinite;
}
@keyframes pulseBtn{
  0%,100%{box-shadow:0 0 0 0 var(--glow),0 8px 20px rgba(0,0,0,.4);}
  50%{box-shadow:0 0 0 8px transparent,0 8px 20px rgba(0,0,0,.4);}
}
.chip-btn{
  height:36px;padding:0 16px;border-radius:99px;
  background:var(--item);color:var(--text);font-size:13px;font-weight:500;
  box-shadow:0 4px 12px rgba(0,0,0,.25);
}
.chip-btn.primary{
  background:linear-gradient(135deg,var(--accent),var(--accent2));
  color:#fff;box-shadow:0 4px 18px var(--glow);
}
.chip-btn.danger{background:rgba(255,59,92,.15);color:var(--danger);border:1px solid rgba(255,59,92,.3);}

/* ============================================================
   SEARCH BAR
============================================================ */
.search-wrap{
  padding:10px 14px;z-index:50;position:relative;
  background:rgba(6,11,20,.5);
  margin-bottom:10px
}
.search-box{
  display:flex;align-items:center;gap:8px;
  background:var(--card);border:1px solid var(--border);
  border-radius:var(--r);padding:10px 14px;
  box-shadow:0 4px 16px rgba(0,0,0,.2);
}
.search-box svg{width:16px;height:16px;opacity:.5;flex-shrink:0;}
#searchInput{
  flex:1;background:none;border:none;outline:none;
  color:var(--text);font-family:var(--font-body);font-size:14px;
  -webkit-user-select:text;user-select:text;
}
#searchInput::placeholder{color:var(--muted);}

/* ============================================================
   TOOLBAR
============================================================ */
.toolbar{
  display:flex;gap:8px;padding:0 14px 10px;
  overflow-x:auto;white-space:nowrap;z-index:35;position:relative;
}
.toolbar::-webkit-scrollbar{display:none;}
/* Custom playlist picker button */
.playlist-btn{
  display:flex;align-items:center;gap:6px;
  background:var(--accent);border:none;
  border-radius:99px;color:#fff;
  font-family:var(--font-body);font-size:13px;font-weight:600;
  height:36px;padding:0 16px 0 14px;
  box-shadow:0 4px 12px var(--glow);
  flex-shrink:0;cursor:pointer;max-width:160px;
  white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
}
.playlist-btn i{ flex-shrink:0; }

/* Playlist picker bottom-sheet */
#playlistPicker{
  position:fixed;inset:0;z-index:300;
  background:rgba(0,0,0,.55);backdrop-filter:blur(4px);
  display:none;align-items:flex-end;
}
#playlistPicker.open{ display:flex; }
#playlistPickerSheet{
  width:100%;background:var(--card);
  border-radius:24px 24px 0 0;
  max-height:70vh;display:flex;flex-direction:column;
  padding-bottom:env(safe-area-inset-bottom,0px);
}
.pp-handle{
  width:36px;height:4px;background:var(--border);
  border-radius:99px;margin:12px auto 4px;flex-shrink:0;
}
.pp-title{
  font-family:var(--font-head);font-size:16px;font-weight:700;
  padding:8px 20px 12px;flex-shrink:0;
  border-bottom:1px solid var(--border);
}
.pp-list{ overflow-y:auto;flex:1; }
.pp-item{
  display:flex;align-items:center;gap:14px;
  padding:14px 20px;cursor:pointer;
  border-bottom:1px solid var(--border);
  transition:background .1s;
}
.pp-item:active{ background:var(--item); }
.pp-item.pp-active{ color:var(--accent); }
.pp-item-icon{
  width:36px;height:36px;border-radius:10px;
  background:var(--item);display:flex;align-items:center;justify-content:center;
  flex-shrink:0;
}
.pp-item.pp-active .pp-item-icon{ background:rgba(0,180,255,.15);color:var(--accent); }
.pp-item-name{ font-size:14px;font-weight:500;flex:1; }
.pp-item-check{ color:var(--accent);display:none; }
.pp-item.pp-active .pp-item-check{ display:block; }

/* ============================================================
   SONG LIST
============================================================ */
#list{
  flex:1;overflow-y:auto;
  padding:8px 14px 240px;
  position:relative;z-index:10;
  scroll-behavior:smooth;
  overscroll-behavior:contain;
}

.song{
  display:flex;align-items:center;gap:12px;
  padding:12px 14px;margin-bottom:8px;
  border-radius:var(--r);
  background:var(--card);
  border:1px solid var(--border);
  cursor:pointer;
  transition:transform .2s,background .2s,box-shadow .2s,border-color .2s;
  position:relative;overflow:hidden;
}
.song::before{
  content:'';position:absolute;inset:0;
  background:linear-gradient(135deg,rgba(0,180,255,.06),transparent);
  opacity:0;transition:opacity .2s;
}
.song:active{transform:scale(.97);}
.song:hover::before{opacity:1;}
.song.active{
  background:linear-gradient(135deg,rgba(0,180,255,.18),rgba(124,58,237,.12));
  border-color:rgba(0,180,255,.4);
  box-shadow:0 0 24px rgba(0,180,255,.18),0 8px 24px rgba(0,0,0,.3);
}
.song-num{
  width:28px;text-align:center;font-size:12px;font-weight:700;
  color:var(--muted);flex-shrink:0;font-family:var(--font-head);
}
.song.active .song-num{
  color:var(--accent);
}
.song-art-mini{
  width:44px;height:44px;border-radius:10px;
  object-fit:cover;flex-shrink:0;
  background:var(--item);
  box-shadow:0 4px 12px rgba(0,0,0,.3);
}
.song-art-mini-canvas{
  width:44px;height:44px;border-radius:10px;flex-shrink:0;
  box-shadow:0 4px 12px rgba(0,0,0,.3);
}
.song-info{flex:1;overflow:hidden;}
.song-title{
  font-size:14px;font-weight:500;
  white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
  margin-bottom:2px;
}
.song.active .song-title{color:#fff;}
.song-sub{font-size:11px;color:var(--muted);}
.song.active .song-sub{color:rgba(255,255,255,.6);}
.song-actions{display:flex;gap:4px;flex-shrink:0;}
.song-actions button{
  width:32px;height:32px;border-radius:10px;
  background:var(--item);color:var(--muted);
  font-size:13px;
}
.song-actions button:active{transform:scale(.88);}
.song-actions .del-btn{color:var(--danger);}
.song.active .song-actions button{background:rgba(255,255,255,.12);color:rgba(255,255,255,.7);}

/* equalizer bars */
.eq-bars{
  display:none;gap:2px;align-items:flex-end;width:18px;height:16px;flex-shrink:0;
}
.eq-bar{
  width:3px;border-radius:2px;
  background:var(--accent);
  animation:eqBounce .6s ease infinite alternate;
}
.eq-bar:nth-child(2){animation-delay:.15s;height:60%;}
.eq-bar:nth-child(3){animation-delay:.3s;height:80%;}
.song.active .eq-bars{display:flex;}
.song.active.paused .eq-bars{animation:none;}
.song.active.paused .eq-bar{animation:none!important;}
@keyframes eqBounce{
  from{transform:scaleY(.4);}
  to{transform:scaleY(1);}
}

/* drag */
.song.dragging{opacity:.4;transform:scale(.95);}
@keyframes shrinkFade{
  to{opacity:0;transform:scale(.9);margin-bottom:0;padding-top:0;padding-bottom:0;min-height:0;height:0;}
}
.song.removing{animation:shrinkFade .3s ease forwards;}

/* ============================================================
   NOW PLAYING FULL SCREEN
============================================================ */
#nowPlaying{
  position:fixed;inset:0;z-index:200;
  display:flex;flex-direction:column;
  background:var(--bg);
  transition:transform .4s cubic-bezier(.32,.72,0,1),opacity .4s;
  transform:translateY(100%);opacity:0;
  pointer-events:none;
}
#nowPlaying.open{
  transform:translateY(0);opacity:1;pointer-events:all;
}
.np-backdrop{
  position:absolute;inset:0;
  background-size:cover;background-position:center;
  filter:blur(50px) saturate(1.4) brightness(.3);
  transform:scale(1.1);
  transition:background-image .4s;
}
.np-content{
  position:relative;z-index:2;
  display:flex;flex-direction:column;
  height:100%;
  padding:max(20px,env(safe-area-inset-top)) 0 0;
}
.np-header{
  display:flex;align-items:center;justify-content:space-between;
  padding:0 20px 16px;
}
.np-label{
  font-size:11px;font-weight:700;letter-spacing:2px;text-transform:uppercase;
  color:rgba(255,255,255,.5);
}
.np-art-wrap{
  flex:1;display:flex;align-items:center;justify-content:center;
  padding:0 32px;min-height:0;
}
.np-art{
  width:100%;max-width:300px;aspect-ratio:1;
  border-radius:24px;
  object-fit:cover;
  box-shadow:0 30px 80px rgba(0,0,0,.7),0 0 60px var(--glow);
  transition:transform .3s,box-shadow .3s;
  animation:npArtFloat 4s ease-in-out infinite;
}
canvas.np-art{display:block;}
@keyframes npArtFloat{
  0%,100%{transform:translateY(0) rotate(0deg);}
  50%{transform:translateY(-8px) rotate(.5deg);}
}
.np-meta{
  padding:20px 28px 8px;
  text-align:center;
}
.np-title{
  font-family:var(--font-head);font-size:22px;font-weight:800;
  color:#fff;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
  margin-bottom:4px;
}
.np-artist{font-size:13px;color:rgba(255,255,255,.5);}

/* fav btn */
.np-fav{
  position:absolute;right:28px;top:0;
  background:none;color:rgba(255,255,255,.4);padding:8px;
}
.np-fav.active{color:#ff6b8a;}

/* progress */
.np-progress{padding:4px 24px 0;}
.np-times{display:flex;justify-content:space-between;font-size:12px;color:rgba(255,255,255,.45);margin-bottom:8px;}
input[type=range].np-seek{
  width:100%;height:4px;appearance:none;-webkit-appearance:none;
  background:rgba(255,255,255,.15);border-radius:99px;outline:none;cursor:pointer;
}
input[type=range].np-seek::-webkit-slider-thumb{
  -webkit-appearance:none;width:18px;height:18px;
  background:#fff;border-radius:50%;
  box-shadow:0 2px 8px rgba(0,0,0,.5);
  cursor:pointer;
}
input[type=range].np-seek::-webkit-slider-runnable-track{border-radius:99px;}

/* controls */
.np-controls{
  display:flex;align-items:center;justify-content:center;
  gap:20px;padding:20px 24px;
}
.np-btn{
  width:52px;height:52px;border-radius:50%;
  background:rgba(255,255,255,.1);color:#fff;
  backdrop-filter:blur(8px);
}
.np-btn.active{background:var(--accent);box-shadow:0 0 20px var(--glow);}
.np-btn-play{
  width:72px;height:72px;border-radius:50%;
  background:#fff;color:#000;
  box-shadow:0 8px 30px rgba(255,255,255,.2);
}
.np-extras{
  display:flex;justify-content:space-between;align-items:center;
  padding:0 28px calc(max(20px,env(safe-area-inset-bottom)) + 20px);
}
.np-vol-wrap{display:flex;align-items:center;gap:10px;flex:1;}
input[type=range].vol-slider{
  flex:1;height:3px;appearance:none;-webkit-appearance:none;
  background:rgba(255,255,255,.2);border-radius:99px;outline:none;cursor:pointer;
}
input[type=range].vol-slider::-webkit-slider-thumb{
  -webkit-appearance:none;width:14px;height:14px;
  background:#fff;border-radius:50%;cursor:pointer;
}

/* ============================================================
   MINI PLAYER
============================================================ */
.mini{
  position:fixed;bottom:calc(110px + var(--safe-bottom));
  left:10px;right:10px;
  height:68px;
  background:var(--card);
  border:1px solid var(--border);
  border-radius:22px;
  display:flex;align-items:center;gap:12px;
  padding:10px 14px;
  box-shadow:0 20px 60px rgba(0,0,0,.5),0 0 0 1px rgba(255,255,255,.05);
  backdrop-filter:blur(30px);-webkit-backdrop-filter:blur(30px);
  z-index:100;
  cursor:pointer;
  transition:transform .3s,opacity .3s;
}
.mini.hidden{display:none;}
.mini-art{
  width:46px;height:46px;border-radius:12px;
  object-fit:cover;flex-shrink:0;
  box-shadow:0 4px 12px rgba(0,0,0,.4);
}
canvas.mini-art{display:block;}
.mini-info{flex:1;overflow:hidden;}
#miniTitle{
  font-size:14px;font-weight:600;
  white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
  margin-bottom:1px;
}
.mini-progress{
  height:2px;background:rgba(255,255,255,.1);border-radius:99px;margin-top:4px;
}
.mini-progress-fill{
  height:100%;background:var(--accent);border-radius:99px;
  width:0%;transition:width .5s linear;
}
.mini-controls{display:flex;gap:6px;flex-shrink:0;}
.mini-controls button{
  width:36px;height:36px;border-radius:50%;
  background:var(--item);color:var(--text);
}
.mini-controls .mini-play{
  background:var(--accent);color:#fff;
  box-shadow:0 4px 12px var(--glow);
}

/* ============================================================
   FOOTER PLAYER
============================================================ */
footer.player-bar{
  position:fixed;bottom:0;left:0;right:0;
  background:rgba(10,18,32,.85);
  border-top:1px solid var(--border);
  backdrop-filter:blur(30px);-webkit-backdrop-filter:blur(30px);
  padding:10px 16px max(20px,var(--safe-bottom));
  z-index:90;
}
footer .seek-row{display:flex;align-items:center;gap:10px;margin-bottom:10px;}
footer .seek-time{font-size:11px;color:var(--muted);font-variant-numeric:tabular-nums;white-space:nowrap;}
input[type=range].seek{
  flex:1;height:3px;appearance:none;-webkit-appearance:none;
  background:rgba(255,255,255,.15);border-radius:99px;outline:none;cursor:pointer;
  accent-color:var(--accent);
}
input[type=range].seek::-webkit-slider-thumb{
  -webkit-appearance:none;width:14px;height:14px;
  background:var(--accent);border-radius:50%;
  box-shadow:0 2px 8px var(--glow);cursor:pointer;
}
.player-buttons{
  display:flex;align-items:center;justify-content:center;gap:12px;
}
.player-buttons button{
  width:44px;height:44px;border-radius:50%;
  background:var(--item);color:var(--text);
  box-shadow:0 4px 12px rgba(0,0,0,.3);
}
.player-buttons .play-btn{
  width:56px;height:56px;
  background:linear-gradient(135deg,var(--accent),var(--accent2));
  color:#fff;
  box-shadow:0 8px 24px var(--glow),0 4px 12px rgba(0,0,0,.4);
}
.player-buttons .active-ctrl{
  background:rgba(0,180,255,.2);color:var(--accent);
  box-shadow:0 0 0 1px rgba(0,180,255,.4),0 4px 12px rgba(0,0,0,.3);
}

/* ============================================================
   MODALS
============================================================ */
.modal-overlay{
  position:fixed;inset:0;z-index:300;
  background:rgba(0,0,0,.7);
  display:flex;align-items:flex-end;justify-content:center;
  opacity:0;pointer-events:none;
  transition:opacity .3s;
  backdrop-filter:blur(4px);-webkit-backdrop-filter:blur(4px);
}
.modal-overlay.open{opacity:1;pointer-events:all;}
.modal{
  background:var(--card);border-radius:28px 28px 0 0;
  width:100%;max-width:600px;
  padding:0 0 max(24px,var(--safe-bottom));
  transform:translateY(30px);
  transition:transform .3s cubic-bezier(.32,.72,0,1);
  max-height:80vh;overflow-y:auto;
}
.modal-overlay.open .modal{transform:translateY(0);}
.modal-handle{
  width:40px;height:4px;border-radius:99px;
  background:rgba(255,255,255,.15);
  margin:12px auto 20px;
}
.modal-title{
  font-family:var(--font-head);font-size:18px;font-weight:700;
  padding:0 24px;margin-bottom:16px;
}
.modal input[type=text]{
  width:calc(100% - 48px);margin:0 24px;
  background:var(--item);border:1px solid var(--border);
  border-radius:14px;color:var(--text);
  font-family:var(--font-body);font-size:15px;
  padding:14px 16px;outline:none;
  -webkit-user-select:text;user-select:text;
}
.modal input[type=text]:focus{border-color:var(--accent);}
.modal-actions{display:flex;gap:10px;padding:16px 24px 0;}
.modal-actions button{flex:1;height:48px;border-radius:14px;font-size:15px;font-weight:600;}
.modal-list-item{
  display:flex;align-items:center;gap:12px;
  padding:14px 24px;cursor:pointer;
  transition:background .2s;
}
.modal-list-item:active{background:var(--item);}
.modal-list-item-icon{
  width:36px;height:36px;border-radius:10px;
  background:var(--item);display:flex;align-items:center;justify-content:center;
  color:var(--accent);flex-shrink:0;
}

/* context menu */
.ctx-menu{
  position:fixed;z-index:400;
  background:var(--card);
  border:1px solid var(--border);
  border-radius:18px;
  padding:8px;
  min-width:180px;
  box-shadow:0 20px 60px rgba(0,0,0,.5);
  opacity:0;pointer-events:none;
  transform:scale(.9);
  transition:opacity .2s,transform .2s;
}
.ctx-menu.open{opacity:1;pointer-events:all;transform:scale(1);}
.ctx-item{
  display:flex;align-items:center;gap:10px;
  padding:10px 14px;border-radius:12px;
  cursor:pointer;font-size:14px;font-weight:500;
  transition:background .15s;
  color:var(--text);
}
.ctx-item:active{background:var(--item);}
.ctx-item.danger{color:var(--danger);}
.ctx-item svg{width:16px;height:16px;flex-shrink:0;opacity:.7;}

/* ============================================================
   SLEEP TIMER PANEL
============================================================ */
.sleep-panel{
  position:fixed;top:70px;right:14px;z-index:150;
  background:var(--card);border:1px solid var(--border);
  border-radius:20px;padding:18px;width:200px;
  box-shadow:0 20px 50px rgba(0,0,0,.5);
  transition:opacity .2s,transform .2s;
  opacity:0;pointer-events:none;transform:scale(.92) translateY(-8px);
}
.sleep-panel.open{opacity:1;pointer-events:all;transform:scale(1) translateY(0);}
.sleep-panel-title{
  font-family:var(--font-head);font-size:14px;font-weight:700;margin-bottom:12px;
  display:flex;justify-content:space-between;align-items:center;
}
.sleep-countdown{
  font-family:var(--font-head);font-size:28px;font-weight:800;text-align:center;
  color:var(--accent);margin-bottom:8px;
}
.sleep-ring{display:block;margin:0 auto 12px;}
.sleep-panel input[type=number]{
  width:100%;background:var(--item);border:1px solid var(--border);
  border-radius:10px;color:var(--text);font-family:var(--font-body);
  font-size:14px;padding:8px 10px;outline:none;margin-bottom:8px;
  -webkit-user-select:text;user-select:text;text-align:center;
}
.sleep-panel button{
  width:100%;height:36px;border-radius:10px;
  font-size:13px;font-weight:600;margin-bottom:6px;
  background:var(--item);color:var(--text);
}
.sleep-panel .start-sleep{background:var(--accent);color:#fff;}
.sleep-panel .cancel-sleep{color:var(--danger);}

/* ============================================================
   MENU DRAWER
============================================================ */
.menu-drawer{
  position:fixed;top:0;left:0;bottom:0;width:280px;z-index:500;
  background:var(--surface);
  border-right:1px solid var(--border);
  padding:max(56px,env(safe-area-inset-top)) 0 max(24px,var(--safe-bottom));
  transform:translateX(-100%);
  transition:transform .35s cubic-bezier(.32,.72,0,1);
  overflow-y:auto;
}
.menu-drawer.open{transform:translateX(0);}
.drawer-overlay{
  position:fixed;inset:0;z-index:490;
  background:rgba(0,0,0,.5);
  opacity:0;pointer-events:none;
  transition:opacity .35s;
  backdrop-filter:blur(4px);-webkit-backdrop-filter:blur(4px);
}
.drawer-overlay.open{opacity:1;pointer-events:all;}
.menu-section{padding:8px 12px;}
.menu-section-label{
  font-size:10px;font-weight:700;letter-spacing:2px;text-transform:uppercase;
  color:var(--muted);padding:8px 12px 4px;
}
.menu-item{
  display:flex;align-items:center;gap:12px;
  padding:13px 14px;border-radius:14px;cursor:pointer;
  color:var(--text);font-size:15px;font-weight:500;
  transition:background .2s;
}
.menu-item:active{background:var(--item);}
.menu-item-icon{
  width:34px;height:34px;border-radius:10px;
  background:var(--item);display:flex;align-items:center;justify-content:center;
  color:var(--accent);flex-shrink:0;
}
.menu-item-right{margin-left:auto;}
.toggle-pill{
  width:44px;height:24px;border-radius:99px;
  background:var(--item);position:relative;transition:background .2s;cursor:pointer;border:none;
}
.toggle-pill::after{
  content:'';position:absolute;width:18px;height:18px;border-radius:50%;
  background:#fff;top:3px;left:3px;transition:transform .2s;
  box-shadow:0 2px 6px rgba(0,0,0,.3);
}
.toggle-pill.on{background:var(--accent);}
.toggle-pill.on::after{transform:translateX(20px);}

/* Drawer header */
.drawer-header{
  display:flex;align-items:center;justify-content:space-between;
  padding:16px 20px 12px;
  border-bottom:1px solid var(--border);
  margin-bottom:8px;
}
.drawer-brand{
  font-family:var(--font-head);font-size:20px;font-weight:800;
  background:linear-gradient(135deg,var(--accent),var(--accent2));
  -webkit-background-clip:text;background-clip:text;
  -webkit-text-fill-color:transparent;
}
.drawer-close-btn{
  width:34px;height:34px;background:var(--item);
}

/* more-btn: make it a reliable click target */
.more-btn{
  pointer-events:all;
  position:relative;z-index:5;
}

/* ============================================================
   TOAST
============================================================ */
#toast{
  position:fixed;bottom:calc(180px + var(--safe-bottom));
  left:50%;transform:translateX(-50%) translateY(8px);
  background:rgba(20,35,55,.95);
  border:1px solid var(--border);
  color:#fff;padding:10px 18px;border-radius:99px;
  font-size:13px;font-weight:500;white-space:nowrap;
  opacity:0;pointer-events:none;
  transition:opacity .3s,transform .3s;
  z-index:9999;backdrop-filter:blur(10px);
  box-shadow:0 8px 30px rgba(0,0,0,.4);
}
#toast.show{opacity:1;transform:translateX(-50%) translateY(0);}

/* ============================================================
   MISC
============================================================ */
.empty-state{
  text-align:center;padding:60px 24px;color:var(--muted);
}
.empty-state svg{width:48px;height:48px;opacity:.3;margin-bottom:12px;}
.empty-state p{font-size:14px;margin-bottom:16px;}
.song-count{
  font-size:11px;color:var(--muted);padding:2px 14px 10px;
  font-family:var(--font-head);letter-spacing:.5px;
}

/* animations */
@keyframes fadeSlideUp{
  from{opacity:0;transform:translateY(12px);}
  to{opacity:1;transform:translateY(0);}
}
.song{animation:fadeSlideUp .25s ease both;}

/* more-btn */
.more-btn{
  width:32px;height:32px;border-radius:10px;
  background:var(--item);color:var(--muted);
  pointer-events:all;position:relative;z-index:5;
}
.song.active .more-btn{background:rgba(255,255,255,.12);color:rgba(255,255,255,.7);}

/* Scan modal */
.scan-section-title{
  font-size:10px;font-weight:700;letter-spacing:1.5px;text-transform:uppercase;
  color:var(--muted);padding:12px 24px 6px;
}
.scan-row{display:flex;align-items:center;justify-content:space-between;padding:10px 24px;}
.scan-row-left{flex:1;padding-right:12px;}
.scan-row-label{font-size:14px;font-weight:500;color:var(--text);}
.scan-row-sub{font-size:11px;color:var(--muted);margin-top:2px;}
.scan-progress-bar-bg{height:5px;background:var(--item);border-radius:99px;overflow:hidden;}
.scan-progress-bar-fill{height:100%;background:linear-gradient(90deg,var(--accent),var(--accent2));border-radius:99px;width:0%;transition:width .4s;}
.scan-stats{display:flex;gap:8px;padding:16px 24px 0;flex-wrap:wrap;}
.scan-stat{background:var(--item);border-radius:12px;padding:10px;font-size:11px;color:var(--muted);flex:1;min-width:60px;text-align:center;}
.scan-stat strong{display:block;font-size:20px;font-weight:800;color:var(--accent);font-family:var(--font-head);line-height:1.2;}
.scan-folder-chip{
  display:flex;align-items:center;gap:8px;
  background:var(--item);border:1px solid var(--border);
  border-radius:14px;padding:10px 14px;margin-bottom:8px;
}
.scan-folder-chip-icon{color:var(--accent);flex-shrink:0;}
.scan-folder-chip-name{flex:1;font-size:13px;font-weight:500;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}
.scan-folder-remove{background:none;color:var(--muted);padding:4px;width:24px;height:24px;border-radius:50%;flex-shrink:0;}
.scan-preset-btn{
  display:inline-flex;align-items:center;gap:5px;
  background:var(--item);border:1px solid var(--border);
  border-radius:99px;padding:6px 12px;font-size:12px;color:var(--text);
  cursor:pointer;transition:.15s;
}
.scan-preset-btn.added{background:rgba(0,180,255,.15);border-color:var(--accent);color:var(--accent);}
.excluded-chip{
  display:inline-flex;align-items:center;gap:5px;
  background:rgba(255,59,92,.1);border:1px solid rgba(255,59,92,.25);
  border-radius:99px;padding:4px 6px 4px 10px;font-size:12px;color:var(--danger);margin:2px;
}
.excluded-chip button{background:none;color:var(--danger);padding:0;width:16px;height:16px;border-radius:50;}

/* ── MULTI-SELECT ── */
.multiselect-bar{
  display:none;align-items:center;gap:10px;
  padding:10px 16px;background:var(--card);
  border-bottom:1px solid var(--border);
  position:sticky;top:0;z-index:30;
}
.multiselect-bar.active{ display:flex; }
.multiselect-count{
  flex:1;font-size:14px;font-weight:600;color:var(--accent);
}
.multiselect-bar .chip-btn{ height:36px;font-size:13px;padding:0 14px; }

.song.selected{
  background:rgba(0,180,255,.12);
  border-left:3px solid var(--accent);
}
.song-checkbox{
  width:22px;height:22px;border-radius:50%;
  border:2px solid var(--muted);background:var(--item);
  flex-shrink:0;display:none;align-items:center;justify-content:center;
  transition:all .15s;
}
.multiselect-active .song-checkbox{ display:flex; }
.song.selected .song-checkbox{
  background:var(--accent);border-color:var(--accent);
  color:#fff;
}
.multiselect-active .song-num{ display:none; }
.multiselect-active .more-btn{ display:none; }

/* ── TRASH DRAWER ITEM badge ── */
.trash-badge{
  min-width:18px;height:18px;background:var(--danger);
  border-radius:99px;font-size:10px;font-weight:700;
  color:#fff;display:inline-flex;align-items:center;
  justify-content:center;padding:0 4px;margin-left:auto;
}

/* ── TRASH VIEW ── */
#trashOverlay{ z-index:200; }
.trash-item{
  display:flex;align-items:center;gap:10px;
  padding:11px 16px;border-bottom:1px solid var(--border);
  cursor:pointer;transition:background .15s;
  -webkit-user-select:none;user-select:none;
}
.trash-item:active{ background:var(--item); }
.trash-item-info{ flex:1;min-width:0; }
.trash-item-name{
  font-size:13px;font-weight:500;color:var(--text);
  white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
}
.trash-item-sub{ font-size:11px;color:var(--muted);margin-top:2px; }
.trash-item-preview{
  width:32px;height:32px;border-radius:50%;flex-shrink:0;
  background:var(--item);color:var(--accent);
  display:flex;align-items:center;justify-content:center;
  transition:background .15s;
}
.trash-item-preview:hover{ background:rgba(0,180,255,.15); }
.trash-item-restore{
  background:var(--item);color:var(--accent);
  border-radius:10px;padding:5px 10px;font-size:12px;font-weight:600;flex-shrink:0;
}
.trash-item-del{
  background:rgba(255,59,92,.12);color:var(--danger);
  border-radius:10px;padding:5px 10px;font-size:12px;font-weight:600;flex-shrink:0;
}

/* ── TRASH MULTI-SELECT ── */
.trash-multibar{
  display:none;align-items:center;gap:8px;
  padding:10px 16px;background:var(--item);
  border-bottom:1px solid var(--border);flex-shrink:0;
}
.trash-multibar.active{ display:flex; }
.trash-multibar-count{ flex:1;font-size:13px;font-weight:600;color:var(--accent); }
.trash-item.t-selected{ background:rgba(0,180,255,.1);border-left:3px solid var(--accent); }

/* checkbox: hidden by default, shown in multiselect */
.trash-item .t-checkbox{
  width:22px;height:22px;border-radius:50%;
  border:2px solid var(--muted);background:var(--item);
  flex-shrink:0;align-items:center;justify-content:center;
  transition:all .15s;
  display:none; /* hidden until multiselect active */
}
.trash-multiactive .trash-item .t-checkbox{ display:flex; }
.trash-item.t-selected .t-checkbox{ background:var(--accent);border-color:var(--accent);color:#fff; }

/* hide action buttons in multiselect */
.trash-multiactive .trash-item-restore,
.trash-multiactive .trash-item-del,
.trash-multiactive .trash-item-preview{ display:none; }

/* Trash preview mini-player bar */
.trash-preview-bar{
  display:none;flex-direction:column;gap:6px;
  padding:10px 16px 12px;background:var(--surface);
  border-top:1px solid var(--border);flex-shrink:0;
}
.trash-preview-bar.visible{ display:flex; }
.trash-preview-row1{ display:flex;align-items:center;gap:10px; }
.trash-preview-title{
  flex:1;font-size:13px;font-weight:600;
  white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:var(--text);
}
.trash-preview-time{ font-size:11px;color:var(--muted);flex-shrink:0; }
#trashPreviewSeek{
  width:100%;height:3px;accent-color:var(--accent);
  background:var(--item);border-radius:99px;cursor:pointer;
  -webkit-appearance:none;appearance:none;
}
.trash-preview-playbtn{
  width:34px;height:34px;border-radius:50%;flex-shrink:0;
  background:var(--accent);color:#fff;
  display:flex;align-items:center;justify-content:center;
}
.trash-preview-stopbtn{
  width:28px;height:28px;border-radius:50%;flex-shrink:0;
  background:var(--item);color:var(--muted);
  display:flex;align-items:center;justify-content:center;
}

/* light mode adjustments */
body.light .bg-blob::before,body.light .bg-blob::after{opacity:.08;}
body.light .topbar,body.light footer.player-bar{background:rgba(238,242,247,.85);}
body.light .mini{background:rgba(255,255,255,.9);}
body.light #nowPlaying{background:var(--bg);}

</style>
</head>

<script>
if("serviceWorker" in navigator){
  navigator.serviceWorker.register("./service-worker.js");
}
</script>

<body>
<div class="bg-blob"></div>

<!-- MENU DRAWER -->
<div class="drawer-overlay" id="drawerOverlay" onclick="closeDrawer()"></div>
<nav class="menu-drawer" id="menuDrawer">
  <div class="drawer-header">
    <span class="drawer-brand">Menu</span>
    <button class="icon-btn drawer-close-btn" onclick="closeDrawer()"><i data-lucide="x"></i></button>
  </div>
  <div class="menu-section">
    <div class="menu-section-label">Library</div>
    <div class="menu-item" onclick="switchToFavourites();closeDrawer()">
      <div class="menu-item-icon" style="color:#ff6b8a"><i data-lucide="heart"></i></div>
      <span>Favourites</span>
    </div>
    <div class="menu-item" onclick="openScanModal();closeDrawer()">
      <div class="menu-item-icon"><i data-lucide="scan-search"></i></div>
      <span>Scan for Songs</span>
    </div>
    <div class="menu-item" onclick="openTrashView();closeDrawer()">
      <div class="menu-item-icon" style="color:var(--danger)"><i data-lucide="trash-2"></i></div>
      <span>Trash</span>
      <span class="trash-badge" id="trashBadge" style="display:none">0</span>
    </div>
  </div>
  <div class="menu-section">
    <div class="menu-section-label">Settings</div>
    <div class="menu-item" onclick="toggleThemeFromDrawer()">
      <div class="menu-item-icon"><i data-lucide="sun"></i></div>
      <span>Light mode</span>
      <button class="toggle-pill menu-item-right" id="themeToggle" onclick="event.stopPropagation();toggleThemeFromDrawer()"></button>
    </div>
    <div class="menu-item" onclick="openSleepPanel();closeDrawer()">
      <div class="menu-item-icon"><i data-lucide="timer"></i></div>
      <span>Sleep timer</span>
    </div>
    <div class="menu-item" onclick="openConverter();closeDrawer()">
      <div class="menu-item-icon"><i data-lucide="arrow-left-right"></i></div>
      <span>Go to Converter</span>
    </div>
    <div class="menu-item" onclick="showAboutModal();closeDrawer()">
      <div class="menu-item-icon"><i data-lucide="info"></i></div>
      <span>About Beast Player</span>
    </div>
  </div>
</nav>

<!-- TOP BAR -->
<header class="topbar">
  <button class="icon-btn" onclick="openDrawer()"><i data-lucide="menu"></i></button>
  <span class="brand">Beast Player</span>
  <div class="topbar-actions">
    <button class="icon-btn" onclick="openScanModal()" title="Scan for music"><i data-lucide="scan-search"></i></button>
    

  </div>
</header>

<!-- SEARCH -->
<div class="search-wrap">
  <div class="search-box">
    <i data-lucide="search"></i>
    <input type="search" id="searchInput" placeholder="Search songs…" oninput="filterSongs(this.value)">
    <button style="background:none;color:var(--muted);width:24px;height:24px;border-radius:50%;padding:0" id="searchClear" onclick="clearSearch()" style="display:none"><i data-lucide="x" style="width:14px;height:14px"></i></button>
  </div>
</div>

<!-- TOOLBAR -->
<div class="toolbar">
<button class="chip-btn" style="background:linear-gradient(135deg,var(--accent),var(--accent2));color:#fff;box-shadow:0 4px 16px var(--glow)" onclick="pickFiles()"><i data-lucide="plus"></i></button>
  <button class="chip-btn" onclick="createPlaylist()"><i data-lucide="folder-plus" style="width:14px;height:14px"></i> New</button>
  <button class="playlist-btn" id="playlistBtn" onclick="openPlaylistPicker()">
    <i data-lucide="list-music" style="width:14px;height:14px;flex-shrink:0"></i>
    <span id="playlistBtnLabel" style="overflow:hidden;text-overflow:ellipsis">All Songs</span>
    <i data-lucide="chevron-up" style="width:12px;height:12px;flex-shrink:0;opacity:.7"></i>
  </button>
  <button class="chip-btn danger" onclick="deletePlaylist()"><i data-lucide="trash-2" style="width:14px;height:14px"></i></button>
  <button class="chip-btn" id="sortBtn" onclick="cycleSortMode()"><i data-lucide="arrow-up-down" style="width:14px;height:14px"></i> <span id="sortLabel">Order</span></button>
</div>

<!-- PLAYLIST PICKER BOTTOM-SHEET -->
<div id="playlistPicker" onclick="e=>{ if(e.target===this) closePlaylistPicker(); }">
  <div id="playlistPickerSheet">
    <div class="pp-handle"></div>
    <div class="pp-title">Switch Playlist</div>
    <div class="pp-list" id="playlistPickerList"></div>
  </div>
</div>

<!-- SONG COUNT -->
<div class="song-count" id="songCount"></div>

<!-- MULTI-SELECT BAR -->
<div class="multiselect-bar" id="multiselectBar">
  <button class="icon-btn" style="width:32px;height:32px;color:var(--muted)" onclick="exitMultiSelect()"><i data-lucide="x" style="width:16px;height:16px"></i></button>
  <span class="multiselect-count" id="multiselectCount">0 selected</span>
  <button class="chip-btn" onclick="multiAddToPlaylist()" style="height:36px;font-size:13px;padding:0 14px"><i data-lucide="folder-input" style="width:13px;height:13px"></i> Add</button>
  <button class="chip-btn danger" onclick="multiDelete()" style="height:36px;font-size:13px;padding:0 14px"><i data-lucide="trash-2" style="width:13px;height:13px"></i> Delete</button>
</div>

<!-- PLAYLIST -->
<div id="list"></div>

<!-- MINI PLAYER -->
<div class="mini hidden" id="miniPlayer" onclick="openNowPlaying()">
  <canvas class="mini-art" id="miniArtCanvas" width="46" height="46"></canvas>
  <div class="mini-info">
    <div id="miniTitle">Not playing</div>
    <div class="mini-progress"><div class="mini-progress-fill" id="miniProgressFill"></div></div>
  </div>
  <div class="mini-controls" onclick="event.stopPropagation()">
    <button class="mini-controls button" onclick="prev()"><i data-lucide="skip-back"></i></button>
    <button class="mini-play" id="miniPlayBtn" onclick="toggle()"><i data-lucide="play"></i></button>
    <button class="mini-controls button" onclick="next()"><i data-lucide="skip-forward"></i></button>
  </div>
</div>

<!-- FOOTER PLAYER -->
<footer class="player-bar">
  <div class="seek-row">
    <span class="seek-time" id="curTime">0:00</span>
    <input type="range" class="seek" id="seek" value="0">
    <span class="seek-time" id="durTime">0:00</span>
  </div>
  <div class="player-buttons">
    <button id="repeatBtn" onclick="toggleRepeat()"><i data-lucide="repeat" id="rp"></i></button>
    <button onclick="prev()"><i data-lucide="skip-back"></i></button>
    <button class="play-btn" id="playBtn" onclick="toggle()"><i data-lucide="play"></i></button>
    <button onclick="next()"><i data-lucide="skip-forward"></i></button>
    <button id="shuffleBtn" onclick="toggleShuffle()"><i data-lucide="shuffle" id="sf"></i></button>
  </div>
</footer>

<!-- NOW PLAYING FULL SCREEN -->
<div id="nowPlaying">
  <div class="np-backdrop" id="npBackdrop"></div>
  <div class="np-content">
    <div class="np-header">
      <button class="icon-btn" style="background:rgba(255,255,255,.1);color:#fff" onclick="closeNowPlaying()">
        <i data-lucide="chevron-down"></i>
      </button>
      <span class="np-label">Now Playing</span>
      <button class="icon-btn" style="background:rgba(255,255,255,.1);color:#fff" onclick="shareCurrentSong()">
        <i data-lucide="share-2"></i>
      </button>
    </div>
    <div class="np-art-wrap">
      <canvas class="np-art" id="npArtCanvas" width="512" height="512"></canvas>
    </div>
    <div class="np-meta" style="position:relative">
      <button class="np-fav" id="npFavBtn" onclick="toggleFav()">
        <i data-lucide="heart"></i>
      </button>
      <div class="np-title" id="npTitle">—</div>
      <div class="np-artist">Beast Player</div>
    </div>
    <div class="np-progress">
      <div class="np-times">
        <span id="npCurTime">0:00</span>
        <span id="npDurTime">0:00</span>
      </div>
      <input type="range" class="np-seek" id="npSeek" value="0">
    </div>
    <div class="np-controls">
      <button class="np-btn" id="npRepeatBtn" onclick="toggleRepeat()"><i data-lucide="repeat"></i></button>
      <button class="np-btn" onclick="prev()"><i data-lucide="skip-back"></i></button>
      <button class="np-btn-play" id="npPlayBtn" onclick="toggle()"><i data-lucide="play"></i></button>
      <button class="np-btn" onclick="next()"><i data-lucide="skip-forward"></i></button>
      <button class="np-btn" id="npShuffleBtn" onclick="toggleShuffle()"><i data-lucide="shuffle"></i></button>
    </div>
    <div class="np-extras">
      <div class="np-vol-wrap">
        <i data-lucide="volume-1" style="width:16px;height:16px;color:rgba(255,255,255,.4)"></i>
        <input type="range" class="vol-slider" id="volSlider" min="0" max="1" step="0.01" value="1" oninput="setVolume(this.value)">
        <i data-lucide="volume-2" style="width:16px;height:16px;color:rgba(255,255,255,.4)"></i>
      </div>
    </div>
  </div>
</div>

<!-- SLEEP TIMER PANEL -->
<div class="sleep-panel" id="sleepPanel">
  <div class="sleep-panel-title">
    Sleep Timer
    <button style="background:none;color:var(--muted);padding:4px" onclick="closeSleepPanel()"><i data-lucide="x" style="width:14px;height:14px"></i></button>
  </div>
  <div class="sleep-countdown" id="sleepCountdown">--:--</div>
  <svg class="sleep-ring" width="90" height="90" viewBox="0 0 90 90" style="transform:rotate(-90deg)">
    <circle cx="45" cy="45" r="38" stroke="rgba(255,255,255,.1)" stroke-width="6" fill="none"/>
    <circle id="sleepProgress" cx="45" cy="45" r="38" stroke="var(--accent)" stroke-width="6" stroke-linecap="round" fill="none"
      stroke-dasharray="239" stroke-dashoffset="239"/>
  </svg>
  <label style="font-size:11px;color:var(--muted);display:block;text-align:center;margin-bottom:6px">Minutes (1–60)</label>
  <input type="number" id="sleepMinutes" min="1" max="60" value="10">
  <button class="start-sleep" onclick="startSleepTimer()">Start</button>
  <button class="cancel-sleep" onclick="cancelSleepTimer()">Cancel</button>
</div>

<!-- CONTEXT MENU -->
<div class="ctx-menu" id="ctxMenu">
  <div class="ctx-item" id="ctxSelect"><i data-lucide="check-square"></i> Select</div>
  <div class="ctx-item" id="ctxPlay"><i data-lucide="play"></i> Play now</div>
  <div class="ctx-item" id="ctxAddPlaylist"><i data-lucide="folder-input"></i> Add to playlist</div>
  <div class="ctx-item" id="ctxRefreshGrad" style="display:none"><i data-lucide="palette"></i> Refresh gradient</div>
  <div class="ctx-item" id="ctxDownload"><i data-lucide="download"></i> Download</div>
  <div class="ctx-item danger" id="ctxDelete"><i data-lucide="trash-2"></i> Move to Trash</div>
</div>

<!-- MODAL: Create playlist / playlist picker -->
<div class="modal-overlay" id="modalOverlay">
  <div class="modal" id="modal">
    <div class="modal-handle"></div>
    <div class="modal-title" id="modalTitle">New playlist</div>
    <div id="modalBody"></div>
  </div>
</div>

<!-- TRASH VIEW -->
<div class="modal-overlay" id="trashOverlay">
  <div class="modal" id="trashModal" style="max-height:92vh;display:flex;flex-direction:column">
    <div class="modal-handle"></div>

    <!-- Normal header -->
    <div id="trashHeader" style="display:flex;align-items:center;justify-content:space-between;padding:0 24px 12px;flex-shrink:0">
      <div>
        <span style="font-family:var(--font-head);font-size:18px;font-weight:700">Trash</span>
        <div style="font-size:11px;color:var(--muted);margin-top:2px">Long-press a song to select • 10-day expiry</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <button id="emptyTrashBtn" style="background:rgba(255,59,92,.12);color:var(--danger);border-radius:10px;padding:6px 12px;font-size:12px;font-weight:600" onclick="emptyTrash()">Empty</button>
        <button style="background:none;color:var(--muted);padding:4px" onclick="closeTrashView()"><i data-lucide="x" style="width:18px;height:18px"></i></button>
      </div>
    </div>

    <!-- Multiselect action bar (shown when selecting) -->
    <div class="trash-multibar" id="trashMultibar">
      <button class="icon-btn" style="width:32px;height:32px;color:var(--muted)" onclick="exitTrashMultiSelect()"><i data-lucide="x" style="width:16px;height:16px"></i></button>
      <span class="trash-multibar-count" id="trashMultiCount">0 selected</span>
      <button class="chip-btn" onclick="trashMultiRestore()" style="height:34px;font-size:12px;padding:0 12px">
        <i data-lucide="rotate-ccw" style="width:12px;height:12px"></i> Restore
      </button>
      <button class="chip-btn danger" onclick="trashMultiDelete()" style="height:34px;font-size:12px;padding:0 12px">
        <i data-lucide="trash-2" style="width:12px;height:12px"></i> Delete
      </button>
      <button class="chip-btn" onclick="trashSelectAll()" style="height:34px;font-size:12px;padding:0 12px;background:var(--item)">
        All
      </button>
    </div>

    <div id="trashList" style="overflow-y:auto;flex:1;padding-bottom:8px"></div>

    <!-- Trash preview player -->
    <div class="trash-preview-bar" id="trashPreviewBar">
      <div class="trash-preview-row1">
        <button class="trash-preview-playbtn" id="trashPreviewPlayBtn" onclick="trashPreviewToggle()">
          <i data-lucide="play" style="width:16px;height:16px"></i>
        </button>
        <span class="trash-preview-title" id="trashPreviewTitle">—</span>
        <span class="trash-preview-time" id="trashPreviewTime">0:00 / 0:00</span>
        <button class="trash-preview-stopbtn" onclick="trashPreviewStop()">
          <i data-lucide="x" style="width:14px;height:14px"></i>
        </button>
      </div>
      <input type="range" id="trashPreviewSeek" value="0" min="0" step="0.1">
    </div>
  </div>
</div>

<!-- SCAN MODAL -->
<div class="modal-overlay" id="scanOverlay">
  <div class="modal" id="scanModal" style="max-height:92vh">
    <div class="modal-handle"></div>
    <div style="display:flex;align-items:center;justify-content:space-between;padding:0 24px 16px">
      <span style="font-family:var(--font-head);font-size:18px;font-weight:700">Scan for Songs</span>
      <button style="background:none;color:var(--muted);padding:4px" onclick="closeScanModal()"><i data-lucide="x" style="width:18px;height:18px"></i></button>
    </div>

    <!-- IDLE STATE -->
    <div id="scanIdle">

      <!-- WHY ROOT DOESN'T WORK — explain + workaround -->
      <div style="margin:0 24px 14px;background:linear-gradient(135deg,rgba(0,180,255,.12),rgba(124,58,237,.08));border:1px solid rgba(0,180,255,.2);border-radius:14px;padding:14px 16px">
        <div style="display:flex;align-items:center;gap:8px;font-size:13px;font-weight:700;color:var(--accent);margin-bottom:5px">
          <i data-lucide="info" style="width:14px;height:14px;flex-shrink:0"></i> Why can't I pick Internal Storage?
        </div>
        <div style="font-size:12px;color:var(--muted);line-height:1.6">
          Chrome blocks access to the storage root to protect your privacy. You'll see <em>"Can't use this folder"</em> if you try.<br><br>
          <strong style="color:var(--text)">Solution:</strong> Tap <strong style="color:var(--text)">+ Add Folder</strong> and navigate to your Music, Downloads, or any other folder. Beast Player will scan everything inside recursively.
        </div>
      </div>

      <!-- Added folders list -->
      <div class="scan-section-title">Folders to Scan <span id="scanFolderCount" style="color:var(--accent);font-size:11px;font-weight:600;margin-left:4px"></span></div>
      <div id="scanFoldersList" style="padding:0 24px 6px"></div>
      <div style="padding:0 24px 12px">
        <button class="chip-btn" style="width:100%;height:42px;border-radius:12px;justify-content:center;gap:8px" onclick="addScanFolder()">
          <i data-lucide="folder-plus" style="width:14px;height:14px"></i> Add Folder
        </button>
      </div>

      <!-- Smart filters -->
      <div class="scan-section-title">Smart Filters</div>
      <div class="scan-row">
        <div class="scan-row-left">
          <div class="scan-row-label">Skip clips shorter than</div>
        </div>
        <div style="display:flex;align-items:center;gap:8px">
          <input type="number" id="scanMinDur" value="10" min="1" max="120"
            style="width:52px;background:var(--item);border:1px solid var(--border);border-radius:10px;color:var(--text);font-size:14px;padding:6px 8px;text-align:center;-webkit-user-select:text;user-select:text;outline:none">
          <span style="font-size:13px;color:var(--muted)">sec</span>
        </div>
      </div>
      <div class="scan-row">
        <div class="scan-row-left">
          <div class="scan-row-label">Skip call &amp; voice recordings</div>
          <div class="scan-row-sub">Call_Records, VoiceMemo, Recorder…</div>
        </div>
        <button class="toggle-pill on" id="scanSkipRec" onclick="this.classList.toggle('on')"></button>
      </div>
      <div class="scan-row">
        <div class="scan-row-left">
          <div class="scan-row-label">Skip notification &amp; UI sounds</div>
          <div class="scan-row-sub">Notification, system beeps, SFX…</div>
        </div>
        <button class="toggle-pill on" id="scanSkipNotif" onclick="this.classList.toggle('on')"></button>
      </div>
      <div class="scan-row">
        <div class="scan-row-left">
          <div class="scan-row-label">Skip ringtones &amp; alarms</div>
          <div class="scan-row-sub">Ringtones, Alarms, MIUI system…</div>
        </div>
        <button class="toggle-pill on" id="scanSkipRing" onclick="this.classList.toggle('on')"></button>
      </div>
      <div class="scan-row">
        <div class="scan-row-left">
          <div class="scan-row-label">Skip WhatsApp / Telegram audio</div>
          <div class="scan-row-sub">Received voice notes, audio files…</div>
        </div>
        <button class="toggle-pill on" id="scanSkipWA" onclick="this.classList.toggle('on')"></button>
      </div>
      <div class="scan-row">
        <div class="scan-row-left">
          <div class="scan-row-label">Skip screen recordings</div>
          <div class="scan-row-sub">ScreenRecording, screenrecord, screen_capture…</div>
        </div>
        <button class="toggle-pill on" id="scanSkipScreen" onclick="this.classList.toggle('on')"></button>
      </div>
      <div class="scan-row">
        <div class="scan-row-left">
          <div class="scan-row-label">Skip trashed &amp; hidden files</div>
          <div class="scan-row-sub">.trashed-, .Trash, .nomedia folders…</div>
        </div>
        <button class="toggle-pill on" id="scanSkipTrashed" onclick="this.classList.toggle('on')"></button>
      </div>

      <!-- Excluded subfolders -->
      <div class="scan-section-title" style="margin-top:4px">Excluded Subfolders</div>
      <div style="padding:0 24px 4px">
        <div id="excludedFolderList" style="margin-bottom:6px"></div>
        <button class="chip-btn" style="height:34px;font-size:12px;border-radius:10px" onclick="addExcludeFolder()">
          <i data-lucide="folder-minus" style="width:12px;height:12px"></i> Exclude a subfolder
        </button>
      </div>

      <div style="padding:16px 24px 4px;display:flex;gap:10px">
        <button class="chip-btn" onclick="closeScanModal()" style="flex:0 0 80px;height:48px;border-radius:14px;font-size:15px;font-weight:600">Cancel</button>
        <button class="chip-btn primary" onclick="startScan()" id="startScanBtn" style="flex:1;height:48px;border-radius:14px;font-size:15px;font-weight:600" disabled>
          <i data-lucide="scan-search" style="width:15px;height:15px"></i> <span id="startScanLabel">Add a folder first</span>
        </button>
      </div>
      <p style="text-align:center;font-size:11px;color:var(--muted);padding:8px 24px 16px;line-height:1.5">
        On Android: tap the folder picker back arrow to navigate up and access other folders like Downloads or DCIM.
      </p>
    </div>

    <!-- RUNNING STATE -->
    <div id="scanRunning" style="display:none;padding:0 0 24px">
      <div class="scan-stats">
        <div class="scan-stat"><strong id="statFound">0</strong>Found</div>
        <div class="scan-stat"><strong id="statSkipped">0</strong>Skipped</div>
        <div class="scan-stat"><strong id="statNew">0</strong>New</div>
      </div>
      <div style="padding:16px 24px 4px">
        <div style="font-size:12px;color:var(--muted);margin-bottom:6px" id="scanStatusText">Scanning…</div>
        <div class="scan-progress-bar-bg"><div class="scan-progress-bar-fill" id="scanProgressFill"></div></div>
      </div>
      <p style="padding:4px 24px;font-size:11px;color:var(--muted);word-break:break-all;min-height:32px" id="scanCurrentFile"></p>
      <div style="padding:8px 24px 0">
        <button class="chip-btn danger" id="scanCancelBtn" onclick="cancelScan()" style="width:100%;height:44px;border-radius:14px;font-size:14px;font-weight:600">Stop Scan</button>
      </div>
    </div>

    <!-- DONE STATE -->
    <div id="scanDone" style="display:none;padding:0 24px 24px;text-align:center">
      <div style="width:56px;height:56px;border-radius:50%;background:linear-gradient(135deg,var(--accent),var(--accent2));display:flex;align-items:center;justify-content:center;margin:20px auto 12px" id="scanDoneIcon">
        <i data-lucide="check" style="width:28px;height:28px;color:#fff"></i>
      </div>
      <div style="font-family:var(--font-head);font-size:20px;font-weight:700;margin-bottom:6px" id="scanDoneTitle">Scan complete</div>
      <div style="font-size:13px;color:var(--muted);margin-bottom:16px" id="scanDoneMsg"></div>
      <div class="scan-stats" style="margin-bottom:20px">
        <div class="scan-stat"><strong id="doneFound">0</strong>Found</div>
        <div class="scan-stat"><strong id="doneSkipped">0</strong>Skipped</div>
        <div class="scan-stat"><strong id="doneAdded">0</strong>Added</div>
        <div class="scan-stat"><strong id="doneDupes">0</strong>Dupes</div>
      </div>
      <button class="chip-btn primary" onclick="closeScanModal()" style="height:48px;border-radius:14px;font-size:15px;font-weight:600;width:100%">Done</button>
    </div>
  </div>
</div>

<div id="toast"></div>
<audio id="audio"></audio>

<script>
/* ================================================================
   STATE
================================================================ */
let db;
let songs = {};
let playlists = {};
let activePlaylist = [];
let activePlaylistId = "all";
let currentIndex = -1;
let isSeeking = false;
let shuffle = false;
let repeatMode = 0; // 0=off 1=all 2=one
let sleepEndTime = 0, sleepTotal = 0, sleepTimerInterval = null;
let artworkCache = {};
let sortMode = 0; // 0=manual 1=az 2=za
let searchQuery = "";
let contextSongId = null;
let npSwipeStartY = 0;
// Stores random extra hue offset per songId so user can "refresh" gradient
let gradientSeeds = JSON.parse(localStorage.getItem("bpGradSeeds")||"{}");
// Multi-select
let multiSelectMode = false;
let selectedIds = new Set();

const audio = document.getElementById("audio");
const list = document.getElementById("list");
const seek = document.getElementById("seek");
const npSeek = document.getElementById("npSeek");
const miniPlayer = document.getElementById("miniPlayer");
const miniTitle = document.getElementById("miniTitle");
const miniProgressFill = document.getElementById("miniProgressFill");
const npBackdrop = document.getElementById("npBackdrop");
const npTitle = document.getElementById("npTitle");
const npCurTime = document.getElementById("npCurTime");
const npDurTime = document.getElementById("npDurTime");
const npPlayBtn = document.getElementById("npPlayBtn");
const npRepeatBtn = document.getElementById("npRepeatBtn");
const npShuffleBtn = document.getElementById("npShuffleBtn");
const npFavBtn = document.getElementById("npFavBtn");
const miniPlayBtn = document.getElementById("miniPlayBtn");
const sleepCountdown = document.getElementById("sleepCountdown");
const sleepProgress = document.getElementById("sleepProgress");
const sleepInput = document.getElementById("sleepMinutes");
const playBtn = document.getElementById("playBtn");
const repeatBtn = document.getElementById("repeatBtn");
const shuffleBtn = document.getElementById("shuffleBtn");

/* ================================================================
   HAPTICS
================================================================ */
function haptic(ms=20){ if(navigator.vibrate) navigator.vibrate(ms); }

/* ================================================================
   THEME
================================================================ */
function applyTheme(light){
  document.body.classList.toggle("light", light);
  const pill = document.getElementById("themeToggle");
  if(pill) pill.classList.toggle("on", light);
  localStorage.setItem("theme", light ? "light" : "dark");
}
function toggleThemeFromDrawer(){
  applyTheme(!document.body.classList.contains("light"));
}
applyTheme(localStorage.getItem("theme") === "light");

/* ================================================================
   DRAWER
================================================================ */
function openDrawer(){ document.getElementById("menuDrawer").classList.add("open"); document.getElementById("drawerOverlay").classList.add("open"); }
function closeDrawer(){ document.getElementById("menuDrawer").classList.remove("open"); document.getElementById("drawerOverlay").classList.remove("open"); }

/* ================================================================
   DATABASE
================================================================ */
const req = indexedDB.open("BeastPlayerDB",3);
req.onupgradeneeded = e => {
  const d = e.target.result;
  if(!d.objectStoreNames.contains("songs")) d.createObjectStore("songs",{keyPath:"id"});
  if(!d.objectStoreNames.contains("playlists")) d.createObjectStore("playlists",{keyPath:"id"});
  if(!d.objectStoreNames.contains("trash")) d.createObjectStore("trash",{keyPath:"id"});
};
req.onsuccess = e => { db = e.target.result; init(); };

function init(){
  const tx = db.transaction("playlists","readwrite");
  const st = tx.objectStore("playlists");
  st.get("all").onsuccess = e => { if(!e.target.result) st.put({id:"all",name:"All Songs",songIds:[]}); };
  st.get("favourites").onsuccess = e => { if(!e.target.result) st.put({id:"favourites",name:"Favourites",songIds:[]}); };
  tx.oncomplete = ()=>{ loadAll(); updateTrashBadge(); };
}

function loadAll(){ loadSongs(loadPlaylists); }

function loadSongs(cb){
  songs = {};
  const tx = db.transaction("songs");
  tx.objectStore("songs").openCursor().onsuccess = e => {
    const c = e.target.result;
    if(c){ songs[c.value.id] = c.value; c.continue(); } else cb();
  };
}

function loadPlaylists(){
  playlists = {};
  const tx = db.transaction("playlists");
  tx.objectStore("playlists").openCursor().onsuccess = e => {
    const c = e.target.result;
    if(c){
      playlists[c.value.id] = c.value;
      c.continue();
    } else {
      // ensure activePlaylistId still exists
      if(!playlists[activePlaylistId]) activePlaylistId = "all";
      updatePlaylistBtn();
      loadPlaylist(activePlaylistId);
    }
  };
}

function updatePlaylistBtn(){
  const lbl = document.getElementById("playlistBtnLabel");
  if(lbl) lbl.textContent = playlists[activePlaylistId]?.name || "All Songs";
}

function openPlaylistPicker(){
  haptic(15);
  const el = document.getElementById("playlistPickerList");
  el.innerHTML = "";
  // Sort: "all" first, "favourites" second, then rest alpha
  const order = ["all","favourites"];
  const sorted = [
    ...order.map(id=>playlists[id]).filter(Boolean),
    ...Object.values(playlists).filter(p=>!order.includes(p.id)).sort((a,b)=>a.name.localeCompare(b.name))
  ];
  sorted.forEach(p=>{
    const isActive = p.id === activePlaylistId;
    const isFav = p.id === "favourites";
    const isAll = p.id === "all";
    const iconName = isAll ? "library" : isFav ? "heart" : "music";
    const iconColor = isFav ? "color:#ff6b8a" : isActive ? "color:var(--accent)" : "";

    const item = document.createElement("div");
    item.className = "pp-item" + (isActive?" pp-active":"");
    item.innerHTML = `
      <div class="pp-item-icon" style="${iconColor}"><i data-lucide="${iconName}" style="width:18px;height:18px"></i></div>
      <span class="pp-item-name">${p.name}</span>
      <i data-lucide="check" class="pp-item-check" style="width:18px;height:18px"></i>
    `;
    item.onclick = () => {
      activePlaylistId = p.id;
      updatePlaylistBtn();
      loadPlaylist(p.id);
      closePlaylistPicker();
    };
    el.appendChild(item);
  });
  lucide.createIcons();
  document.getElementById("playlistPicker").classList.add("open");
}

function closePlaylistPicker(){
  document.getElementById("playlistPicker").classList.remove("open");
}

// Close on backdrop tap
document.getElementById("playlistPicker").addEventListener("click", e=>{
  if(e.target === document.getElementById("playlistPicker")) closePlaylistPicker();
});

function loadPlaylist(id){
  activePlaylistId = id;
  const p = playlists[id];
  if(!p) return;
  activePlaylist = p.songIds.map(i=>songs[i]).filter(Boolean);
  if(currentIndex !== -1){
    // maintain currentIndex after re-load
    const cur = activePlaylist.findIndex(s => s === activePlaylist[currentIndex]);
    currentIndex = cur >= 0 ? cur : -1;
  }
  renderList();
}

/* ================================================================
   RENDER
================================================================ */
function getFilteredSorted(){
  let arr = [...activePlaylist];
  if(searchQuery){
    const q = searchQuery.toLowerCase();
    arr = arr.filter(s => s.name.toLowerCase().includes(q));
  }
  if(sortMode === 1) arr.sort((a,b)=>a.name.localeCompare(b.name));
  else if(sortMode === 2) arr.sort((a,b)=>b.name.localeCompare(a.name));
  return arr;
}

function renderList(){
  const filtered = getFilteredSorted();
  list.innerHTML = "";

  // song count
  const countEl = document.getElementById("songCount");
  countEl.textContent = filtered.length + " song" + (filtered.length!==1?"s":"") + (searchQuery?" matching":"");

  // apply multiselect class to list container
  list.classList.toggle("multiselect-active", multiSelectMode);

  if(!filtered.length){
    list.innerHTML = `<div class="empty-state">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M9 18V5l12-2v13"/><circle cx="6" cy="18" r="3"/><circle cx="18" cy="16" r="3"/></svg>
      <p>${searchQuery ? "No songs match your search." : "No songs yet — tap <strong>Add</strong> to import music."}</p>
    </div>`;
    return;
  }

  filtered.forEach((s,i)=>{
    const realIdx = activePlaylist.indexOf(s);
    const isActive = realIdx === currentIndex;
    const isSelected = selectedIds.has(s.id);
    const d = document.createElement("div");
    d.className = "song" + (isActive?" active":"") + (isActive&&audio.paused?" paused":"") + (isSelected?" selected":"");
    d.style.animationDelay = (i*25)+"ms";

    // drag (only in non-multiselect)
    d.draggable = sortMode===0 && !multiSelectMode;
    d.ondragstart = e => { e.dataTransfer.setData("text/plain", realIdx); d.classList.add("dragging"); };
    d.ondragend = () => d.classList.remove("dragging");
    d.ondragover = e => e.preventDefault();
    d.ondrop = e => {
      e.preventDefault();
      const from = +e.dataTransfer.getData("text/plain");
      const to = realIdx;
      if(from===to) return;
      const song = activePlaylist.splice(from,1)[0];
      activePlaylist.splice(to,0,song);
      if(currentIndex===from) currentIndex=to;
      else if(currentIndex>from&&currentIndex<=to) currentIndex--;
      else if(currentIndex<from&&currentIndex>=to) currentIndex++;
      savePlaylistOrder();
      renderList();
    };

    // checkbox (shown in multiselect mode)
    const chk = document.createElement("div");
    chk.className = "song-checkbox";
    chk.innerHTML = isSelected ? '<i data-lucide="check" style="width:12px;height:12px"></i>' : '';

    // eq bars
    const eq = document.createElement("div");
    eq.className="eq-bars";
    eq.innerHTML='<div class="eq-bar"></div><div class="eq-bar"></div><div class="eq-bar"></div>';

    // number/eq
    const num = document.createElement("div");
    num.className="song-num";
    if(isActive) num.appendChild(eq); else num.textContent=i+1;

    // art
    const artC = document.createElement("canvas");
    artC.className="song-art-mini-canvas";
    artC.width=44; artC.height=44;
    drawArtOnCanvas(s, artC);

    // info
    const info = document.createElement("div");
    info.className="song-info";
    const cleanName = s.name.replace(/\.[^.]+$/,"");
    info.innerHTML=`<div class="song-title">${cleanName}</div><div class="song-sub">${formatTime(s.duration||0)} • ${s.name.split(".").pop().toUpperCase()}</div>`;

    // actions
    const acts = document.createElement("div");
    acts.className="song-actions";

    const moreBtn = document.createElement("button");
    moreBtn.innerHTML='<i data-lucide="more-vertical"></i>';
    moreBtn.className = "more-btn";
    acts.appendChild(moreBtn);

    d.append(chk, num, artC, info, acts);

    // ── Long-press → enter multi-select ──
    // Only when sortMode !== 0 (drag mode). In drag mode, long-press
    // is the native drag gesture — multiselect uses the ⋮ menu "Select".
    let pressTimer;
    const startPress = () => {
      if(sortMode === 0 && !multiSelectMode) return; // drag mode — no long-press select
      pressTimer = setTimeout(()=>{
        haptic(40);
        if(!multiSelectMode) enterMultiSelect(s.id);
        else toggleSongSelection(s.id, d, chk);
      }, 500);
    };
    const cancelPress = () => clearTimeout(pressTimer);
    d.addEventListener("touchstart", startPress, {passive:true});
    d.addEventListener("touchend",   cancelPress, {passive:true});
    d.addEventListener("touchmove",  cancelPress, {passive:true});
    d.addEventListener("mousedown",  e => { if(e.button===0) startPress(); });
    d.addEventListener("mouseup",    cancelPress);
    d.addEventListener("mousemove",  cancelPress);

    d.onclick = (e) => {
      if(e.target.closest(".more-btn")){
        e.stopPropagation();
        openCtxMenu(e, s.id);
        return;
      }
      if(multiSelectMode){
        toggleSongSelection(s.id, d, chk);
        return;
      }
      play(realIdx);
    };
    list.appendChild(d);
  });

  lucide.createIcons();
}

/* ================================================================
   ARTWORK
================================================================ */
function drawArtOnCanvas(song, canvas){
  const ctx = canvas.getContext("2d");
  const w = canvas.width, h = canvas.height;
  if(artworkCache[song.id]){
    const img = new Image();
    img.onload = ()=>ctx.drawImage(img,0,0,w,h);
    img.src = artworkCache[song.id];
    return;
  }
  // fallback gradient (uses seed if user refreshed)
  drawFallbackCanvas(ctx, song.name, w, h, song.id);
  // try to load embedded tag art
  getArtwork(song.blob).then(url=>{
    if(url){
      artworkCache[song.id] = url;
      const img = new Image();
      img.onload = ()=>{ ctx.drawImage(img,0,0,w,h); };
      img.src = url;
    }
  });
}

function drawFallbackCanvas(ctx, name, w, h, songId){
  const base = [...name].reduce((a,c)=>a+c.charCodeAt(0),0);
  const seed = (songId && gradientSeeds[songId]) ? gradientSeeds[songId] : 0;
  const h1 = (base + seed) % 360;
  const h2 = (base * 137 + seed * 73) % 360;
  const grd = ctx.createLinearGradient(0,0,w,h);
  grd.addColorStop(0,`hsl(${h1},65%,42%)`);
  grd.addColorStop(1,`hsl(${h2},65%,32%)`);
  ctx.fillStyle=grd; ctx.fillRect(0,0,w,h);
  ctx.fillStyle="rgba(255,255,255,.9)";
  ctx.font=`bold ${Math.floor(w*.32)}px sans-serif`;
  ctx.textAlign="center"; ctx.textBaseline="middle";
  ctx.fillText((name.trim()[0]||"?").toUpperCase(), w/2, h/2);
}

function getArtwork(blob){
  return new Promise(res=>{
    try{
      jsmediatags.read(blob,{
        onSuccess:t=>{ const p=t.tags.picture; if(!p) return res(null); res(URL.createObjectURL(new Blob([new Uint8Array(p.data)],{type:p.format}))); },
        onError:()=>res(null)
      });
    }catch(e){res(null);}
  });
}

async function updateNpArt(song){
  const npC = document.getElementById("npArtCanvas");
  const miniC = document.getElementById("miniArtCanvas");
  if(!song) return;

  const cleanTitle = song.name.replace(/\.[^.]+$/,"");

  // ── SET MEDIA SESSION METADATA IMMEDIATELY (synchronous) ──
  // This is critical: set metadata NOW with the app icon as fallback
  // artwork so the lock screen notification NEVER disappears between
  // songs. We update artwork again once we've loaded the real image.
  if(navigator.mediaSession){
    navigator.mediaSession.metadata = new MediaMetadata({
      title:  cleanTitle,
      artist: "Beast Player",
      album:  "",
      artwork: [
        { src: "./icon-192.png", sizes: "192x192", type: "image/png" },
        { src: "./icon-512.png", sizes: "512x512", type: "image/png" }
      ]
    });
  }

  // ── LOAD REAL ARTWORK (async — updates notification once ready) ──
  let artUrl = artworkCache[song.id];
  if(!artUrl){
    artUrl = await getArtwork(song.blob);
    if(artUrl) artworkCache[song.id] = artUrl;
  }

  function drawTo(canvas, size){
    const ctx = canvas.getContext("2d");
    if(artUrl){
      const img = new Image();
      img.onload = ()=>ctx.drawImage(img,0,0,size,size);
      img.src = artUrl;
    } else {
      drawFallbackCanvas(ctx, song.name, size, size, song.id);
    }
  }

  npC.width=npC.height=512;
  miniC.width=miniC.height=46;
  drawTo(npC, 512);
  drawTo(miniC, 46);

  // backdrop
  npBackdrop.style.backgroundImage = artUrl ? `url(${artUrl})` : "none";
  if(!artUrl){
    const base = [...song.name].reduce((a,c)=>a+c.charCodeAt(0),0);
    const seed = (gradientSeeds[song.id]||0);
    const bh1 = (base+seed)%360, bh2 = (base*137+seed*73)%360;
    npBackdrop.style.background = `linear-gradient(135deg,hsl(${bh1},65%,25%),hsl(${bh2},65%,15%))`;
  }

  // ── UPDATE NOTIFICATION ARTWORK once we have real/fallback art ──
  if(navigator.mediaSession){
    let notifArt = artUrl;
    if(!notifArt){
      // Generate a coloured gradient with the song initial
      const hh = [...song.name].reduce((a,c)=>a+c.charCodeAt(0),0);
      const fc = document.createElement("canvas"); fc.width=fc.height=512;
      const fg = fc.getContext("2d");
      const grd = fg.createLinearGradient(0,0,512,512);
      grd.addColorStop(0, `hsl(${hh%360},70%,45%)`);
      grd.addColorStop(1, `hsl(${(hh*137)%360},70%,35%)`);
      fg.fillStyle=grd; fg.fillRect(0,0,512,512);
      fg.fillStyle="rgba(255,255,255,.9)"; fg.font="bold 160px sans-serif";
      fg.textAlign="center"; fg.textBaseline="middle";
      fg.fillText((song.name.trim()[0]||"♪").toUpperCase(),256,256);
      notifArt = fc.toDataURL();
    }
    // Only update if this song is still playing (async race guard)
    if(activePlaylist[currentIndex]?.id === song.id){
      navigator.mediaSession.metadata = new MediaMetadata({
        title:  cleanTitle,
        artist: "Beast Player",
        album:  "",
        artwork: [{ src: notifArt, sizes:"512x512", type:"image/png" }]
      });
    }
  }
}

/* ================================================================
   SCAN FOR SONGS — multi-folder approach
================================================================ */
let scanCancelled = false;
let scanFolderHandles = []; // array of {name, handle}
let excludedFolders = JSON.parse(localStorage.getItem("excludedFolders")||"[]");

const SKIP_REC_FOLDERS   = ["Call_Records","CallRecord","VoiceRecorder","VoiceMemo","Recorder","Recordings","PhoneRecord","CallRecording","rec"];
const SKIP_NOTIF_FOLDERS = ["Notifications","Notification","System","MIUI","SystemSounds","UI"];
const SKIP_RING_FOLDERS  = ["Ringtones","Ringtone","Alarms","Alarm","MIUI"];
const SKIP_WA_FOLDERS    = ["WhatsApp Audio","WhatsApp Voice Notes","Telegram Audio","Telegram Voice","Signal","Viber"];
const SKIP_SCREEN_FOLDERS= [".Trash","Trash",".trashed"];

const SKIP_REC_PATT    = [/call.?rec/i,/voice.?rec/i,/calllog/i,/rec.?call/i,/call.?memo/i,/ptt_\d/i];
const SKIP_NOTIF_PATT  = [/notification/i,/system/i,/ui[_-]?sfx/i,/beep/i,/keypress/i,/click/i,/soundfx/i];
const SKIP_RING_PATT   = [/ringtone/i,/^alarm/i,/default_/i];
const SKIP_WA_PATT     = [/whatsapp/i,/telegram/i,/signal/i,/messenger/i,/viber/i];
const SKIP_SCREEN_PATT = [/screen.?rec/i,/screenrecord/i,/screen_record/i,/screen.?capture/i,/screencapture/i,/scr_/i,/rec_\d{4}/i];
const SKIP_TRASH_PATT  = [/^\.trashed[-_]/i,/^\.trash/i];

const AUDIO_EXTS = new Set(["mp3","wav","flac","aac","ogg","m4a","opus","wma","aiff","mp4","webm","m4b"]);

function openScanModal(){
  haptic(15);
  scanFolderHandles = [];
  renderScanFolders();
  renderExcludedFolders();
  showScanState("idle");
  document.getElementById("scanOverlay").classList.add("open");
  lucide.createIcons();
}
function closeScanModal(){
  scanCancelled = true;
  document.getElementById("scanOverlay").classList.remove("open");
}
function cancelScan(){ scanCancelled=true; }
function showScanState(s){
  document.getElementById("scanIdle").style.display    = s==="idle"    ?"":"none";
  document.getElementById("scanRunning").style.display = s==="running" ?"":"none";
  document.getElementById("scanDone").style.display    = s==="done"    ?"":"none";
}

async function addScanFolder(){
  if(!window.showDirectoryPicker){ toast("Not supported on this browser"); return; }
  haptic(15);
  try {
    const handle = await window.showDirectoryPicker({mode:"read"});
    addFolderHandle(handle);
  } catch(e){ if(e.name!=="AbortError") toast("Cancelled"); }
}

function addFolderHandle(handle){
  // deduplicate by name
  if(scanFolderHandles.find(f=>f.name===handle.name)){
    toast(`"${handle.name}" already added`); return;
  }
  scanFolderHandles.push({name:handle.name, handle});
  renderScanFolders();
  updateStartBtn();
  toast(`Added: ${handle.name}`);
}

function removeScanFolder(i){
  scanFolderHandles.splice(i,1);
  renderScanFolders();
  updateStartBtn();
}

function updateStartBtn(){
  const btn = document.getElementById("startScanBtn");
  const lbl = document.getElementById("startScanLabel");
  const cnt = document.getElementById("scanFolderCount");
  if(!btn) return;
  const n = scanFolderHandles.length;
  btn.disabled = n === 0;
  if(lbl) lbl.textContent = n ? `Scan ${n} folder${n!==1?"s":""}` : "Add a folder first";
  if(cnt) cnt.textContent = n ? `(${n})` : "";
}

function renderScanFolders(){
  const el = document.getElementById("scanFoldersList");
  if(!el) return;
  if(!scanFolderHandles.length){
    el.innerHTML='<p style="padding:4px 0 8px;font-size:12px;color:var(--muted)">No folders added yet — use Quick Add above or tap + Add Folder.</p>';
    return;
  }
  el.innerHTML = scanFolderHandles.map((f,i)=>`
    <div style="display:flex;align-items:center;gap:10px;padding:10px 0;border-bottom:1px solid var(--border)">
      <i data-lucide="folder" style="width:16px;height:16px;color:var(--accent);flex-shrink:0"></i>
      <span style="flex:1;font-size:13px;font-weight:500;color:var(--text);word-break:break-all">${f.name}</span>
      <button onclick="removeScanFolder(${i})" style="background:var(--item);color:var(--muted);padding:4px 10px;border-radius:8px;font-size:12px;flex-shrink:0">Remove</button>
    </div>`).join("");
  lucide.createIcons();
}

function renderExcludedFolders(){
  const el = document.getElementById("excludedFolderList");
  if(!el) return;
  if(!excludedFolders.length){
    el.innerHTML='<span style="font-size:12px;color:var(--muted)">None added</span>';
    return;
  }
  el.innerHTML = excludedFolders.map((f,i)=>
    `<span class="excluded-chip">${f}<button onclick="removeExcluded(${i})"><i data-lucide="x" style="width:10px;height:10px"></i></button></span>`
  ).join("");
  lucide.createIcons();
}

function addExcludeFolder(){
  if(window.showDirectoryPicker){
    window.showDirectoryPicker({mode:"read"}).then(dir=>{
      if(!excludedFolders.includes(dir.name)){
        excludedFolders.push(dir.name);
        localStorage.setItem("excludedFolders",JSON.stringify(excludedFolders));
        renderExcludedFolders(); toast(`"${dir.name}" will be excluded`);
      } else toast("Already excluded");
    }).catch(()=>{});
  } else {
    openModal("Exclude Subfolder",
      `<input type="text" id="exIn" placeholder="Folder name e.g. Recorder" maxlength="80" style="margin-bottom:0">`,
      ()=>{ const v=document.getElementById("exIn").value.trim(); if(!v) return;
        if(!excludedFolders.includes(v)){ excludedFolders.push(v); localStorage.setItem("excludedFolders",JSON.stringify(excludedFolders)); renderExcludedFolders(); }
      },"Add","Cancel");
    setTimeout(()=>document.getElementById("exIn")?.focus(),200);
  }
}

function removeExcluded(i){
  excludedFolders.splice(i,1);
  localStorage.setItem("excludedFolders",JSON.stringify(excludedFolders));
  renderExcludedFolders();
}

function folderShouldSkip(name, skipRec, skipNotif, skipRing, skipWA, skipScreen, skipTrashed){
  const n = name.toLowerCase();
  if(excludedFolders.some(f=>n===f.toLowerCase())) return true;
  if(skipTrashed && (n.startsWith(".trash") || n.startsWith(".nomedia") || SKIP_SCREEN_FOLDERS.some(f=>n===f.toLowerCase()))) return true;
  if(skipRec   && SKIP_REC_FOLDERS.some(f=>n.includes(f.toLowerCase()))) return true;
  if(skipNotif && SKIP_NOTIF_FOLDERS.some(f=>n.includes(f.toLowerCase()))) return true;
  if(skipRing  && SKIP_RING_FOLDERS.some(f=>n.includes(f.toLowerCase()))) return true;
  if(skipWA    && SKIP_WA_FOLDERS.some(f=>n.includes(f.toLowerCase()))) return true;
  return false;
}

function fileShouldSkip(name, path, skipRec, skipNotif, skipRing, skipWA, skipScreen, skipTrashed){
  const full = (path+"/"+name).toLowerCase();
  const fname = name.toLowerCase();
  if(skipTrashed && SKIP_TRASH_PATT.some(p=>p.test(fname))) return true;
  if(skipScreen  && SKIP_SCREEN_PATT.some(p=>p.test(fname))) return true;
  if(skipRec   && SKIP_REC_PATT.some(p=>p.test(full))) return true;
  if(skipNotif && SKIP_NOTIF_PATT.some(p=>p.test(full))) return true;
  if(skipRing  && SKIP_RING_PATT.some(p=>p.test(full))) return true;
  if(skipWA    && SKIP_WA_PATT.some(p=>p.test(full))) return true;
  return false;
}

async function startScan(){
  if(!scanFolderHandles.length){ toast("Add at least one folder first"); return; }
  haptic(20);

  const minDur     = Math.max(0,+document.getElementById("scanMinDur").value||10);
  const skipRec    = document.getElementById("scanSkipRec").classList.contains("on");
  const skipNotif  = document.getElementById("scanSkipNotif").classList.contains("on");
  const skipRing   = document.getElementById("scanSkipRing").classList.contains("on");
  const skipWA     = document.getElementById("scanSkipWA").classList.contains("on");
  const skipScreen = document.getElementById("scanSkipScreen").classList.contains("on");
  const skipTrashed= document.getElementById("scanSkipTrashed").classList.contains("on");

  scanCancelled = false;
  showScanState("running");
  document.getElementById("scanCancelBtn").textContent="Stop Scan";

  const existingNames = new Set(Object.values(songs).map(s=>s.name));
  let countFound=0, countSkipped=0, countNew=0, countDupe=0;
  const fileQueue = [];

  function setStat(id,v){ const e=document.getElementById(id); if(e) e.textContent=v; }
  function setStatus(t){ const e=document.getElementById("scanStatusText"); if(e) e.textContent=t; }
  function setCurrent(t){ const e=document.getElementById("scanCurrentFile"); if(e) e.textContent=t; }

  async function collectFiles(handle, path){
    if(scanCancelled) return;
    try {
      for await(const [name, entry] of handle.entries()){
        if(scanCancelled) return;
        if(entry.kind==="directory"){
          if(folderShouldSkip(name, skipRec, skipNotif, skipRing, skipWA, skipScreen, skipTrashed)) continue;
          await collectFiles(entry, path?path+"/"+name:name);
        } else {
          const ext=name.split(".").pop().toLowerCase();
          if(!AUDIO_EXTS.has(ext)) continue;
          if(fileShouldSkip(name, path||"", skipRec, skipNotif, skipRing, skipWA, skipScreen, skipTrashed)) continue;
          fileQueue.push({name, entry, path:path||""});
          setStat("statFound", ++countFound);
          setCurrent(name);
        }
      }
    } catch(e){}
  }

  setStatus("Collecting files…");
  for(const folder of scanFolderHandles){
    if(scanCancelled) break;
    setStatus(`Scanning "${folder.name}"…`);
    await collectFiles(folder.handle, folder.name);
  }

  if(scanCancelled){ showScanState("idle"); return; }
  if(!fileQueue.length){ toast("No audio files found in selected folders"); showScanState("idle"); return; }

  setStatus(`Checking ${fileQueue.length} files…`);
  const validFiles=[];

  for(let i=0;i<fileQueue.length;i++){
    if(scanCancelled) break;
    document.getElementById("scanProgressFill").style.width=((i+1)/fileQueue.length*100)+"%";
    const {name,entry,path}=fileQueue[i];
    setCurrent(name);
    try {
      const file = await entry.getFile();
      if(existingNames.has(name)){ countDupe++; setStat("statSkipped",++countSkipped); continue; }
      if(minDur>0){
        const dur=await new Promise(res=>{
          const url=URL.createObjectURL(file), a=new Audio();
          a.onloadedmetadata=()=>{ URL.revokeObjectURL(url); res(a.duration); };
          a.onerror=()=>{ URL.revokeObjectURL(url); res(0); };
          a.src=url; setTimeout(()=>res(0),3000);
        });
        if(dur<minDur){ setStat("statSkipped",++countSkipped); continue; }
      }
      validFiles.push({name,blob:file});
      setStat("statNew",++countNew);
    } catch(e){ setStat("statSkipped",++countSkipped); }
  }

  if(!validFiles.length){
    setStat("doneFound",countFound); setStat("doneSkipped",countSkipped);
    setStat("doneAdded",0); setStat("doneDupes",countDupe);
    const icon = document.getElementById("scanDoneIcon");
    if(icon) icon.innerHTML='<i data-lucide="search" style="width:28px;height:28px;color:#fff"></i>';
    document.getElementById("scanDoneTitle").textContent = scanCancelled?"Scan stopped":"Nothing new found";
    document.getElementById("scanDoneMsg").textContent = `${countDupe} already in library, ${countSkipped-countDupe} skipped by filters.`;
    showScanState("done"); lucide.createIcons(); return;
  }

  setStatus(`Saving ${validFiles.length} songs…`);
  const tx=db.transaction(["songs","playlists"],"readwrite");
  const sStore=tx.objectStore("songs"), pStore=tx.objectStore("playlists");
  pStore.get("all").onsuccess=e=>{
    const all=e.target.result;
    validFiles.forEach(s=>{ const id=crypto.randomUUID(); sStore.put({id,name:s.name,blob:s.blob,duration:0}); all.songIds.push(id); });
    pStore.put(all);
  };
  tx.oncomplete=()=>{
    loadAll();
    setStat("doneFound",countFound); setStat("doneSkipped",countSkipped);
    setStat("doneAdded",countNew);   setStat("doneDupes",countDupe);
    document.getElementById("scanDoneTitle").textContent="Scan complete!";
    document.getElementById("scanDoneMsg").textContent=`Added ${countNew} new song${countNew!==1?"s":""}. ${countDupe} duplicate${countDupe!==1?"s":""} skipped.`;
    showScanState("done");
  };
}

document.getElementById("scanOverlay").addEventListener("click",e=>{
  if(e.target===document.getElementById("scanOverlay")) closeScanModal();
});

/* ================================================================
   PLAYER
================================================================ */
function play(i){
  haptic(20);
  if(!activePlaylist[i]) return;
  const prevIndex = currentIndex;
  currentIndex = i;
  const song = activePlaylist[i];

  // Revoke previous src URL if we created it (avoid memory leak)
  const oldSrc = audio.src;
  audio.src = getOrCreateUrl(song); // use pre-loaded URL if available
  if(oldSrc && oldSrc.startsWith("blob:")) URL.revokeObjectURL(oldSrc);

  audio.play().then(()=>{
    setPlaybackState("playing");
    preloadNextSong();        // pre-load next song while current plays
  }).catch(e=>{ if(e.name!=="AbortError") toast("Playback error"); });

  miniPlayer.classList.remove("hidden");
  miniTitle.textContent = song.name.replace(/\.[^.]+$/,"");
  npTitle.textContent = song.name.replace(/\.[^.]+$/,"");
  updateNpArt(song);
  updatePlayIcons();
  updateControlStates();
  updateFavUI();
  updateActiveRow(prevIndex, i);

  // save duration lazily
  audio.onloadedmetadata = ()=>{
    updatePositionState(); // lock screen progress bar
    if(!song.duration || Math.abs(song.duration - audio.duration) > 1){
      song.duration = audio.duration;
      const tx = db.transaction("songs","readwrite");
      tx.objectStore("songs").put({...song});
      const filtered = getFilteredSorted();
      const fi = filtered.findIndex(s=>s&&s.id===song.id);
      if(fi >= 0){
        const row = list.querySelectorAll(".song")[fi];
        if(row){
          const sub = row.querySelector(".song-sub");
          if(sub) sub.textContent = `${formatTime(audio.duration)} • ${song.name.split(".").pop().toUpperCase()}`;
        }
      }
    }
  };
}

// Surgically swap active class between old and new rows — zero flicker
function updateActiveRow(prevIdx, nextIdx){
  const rows = list.querySelectorAll(".song");
  const filtered = getFilteredSorted();

  // deactivate previous row
  if(prevIdx >= 0 && activePlaylist[prevIdx]){
    const fi = filtered.findIndex(s=>s&&s.id===activePlaylist[prevIdx].id);
    if(fi >= 0 && rows[fi]){
      rows[fi].classList.remove("active","paused");
      const numEl = rows[fi].querySelector(".song-num");
      if(numEl){ numEl.innerHTML=""; numEl.textContent = fi+1; }
    }
  }

  // activate next row
  if(nextIdx >= 0 && activePlaylist[nextIdx]){
    const fi = filtered.findIndex(s=>s&&s.id===activePlaylist[nextIdx].id);
    if(fi >= 0 && rows[fi]){
      rows[fi].classList.add("active");
      rows[fi].classList.remove("paused");
      const numEl = rows[fi].querySelector(".song-num");
      if(numEl) numEl.innerHTML='<div class="eq-bars"><div class="eq-bar"></div><div class="eq-bar"></div><div class="eq-bar"></div></div>';
      rows[fi].scrollIntoView({behavior:"smooth", block:"nearest"});
    }
  }
}

function toggle(){
  haptic(25);
  if(audio.paused){
    audio.play().then(()=>{ setPlaybackState("playing"); }).catch(()=>{});
  } else {
    audio.pause();
    setPlaybackState("paused");
  }
}

function prev(){
  if(audio.currentTime>5){ audio.currentTime=0; return; }
  if(shuffle){ play(Math.floor(Math.random()*activePlaylist.length)); return; }
  if(currentIndex>0) play(currentIndex-1);
}

function next(){
  if(activePlaylist.length===0||currentIndex===-1) return;
  if(repeatMode===2){ play(currentIndex); return; }
  if(shuffle){
    let n; do{ n=Math.floor(Math.random()*activePlaylist.length); }while(activePlaylist.length>1&&n===currentIndex);
    play(n); return;
  }
  if(currentIndex<activePlaylist.length-1) play(currentIndex+1);
  else if(repeatMode===1) play(0);
  else { currentIndex=-1; updatePlayIcons(); setPlaybackState("none"); }
}

audio.onplay = ()=>{
  setPlaybackState("playing");
  updatePlayIcons();
  if(currentIndex>=0 && activePlaylist[currentIndex]){
    const fi = getFilteredSorted().findIndex(s=>s&&s.id===activePlaylist[currentIndex].id);
    if(fi>=0) list.querySelectorAll(".song")[fi]?.classList.remove("paused");
  }
};
audio.onpause = ()=>{
  setPlaybackState("paused");
  updatePlayIcons();
  if(currentIndex>=0 && activePlaylist[currentIndex]){
    const fi = getFilteredSorted().findIndex(s=>s&&s.id===activePlaylist[currentIndex].id);
    if(fi>=0) list.querySelectorAll(".song")[fi]?.classList.add("paused");
  }
};
audio.onended = next;

// Stall recovery — if audio gets stuck (common when screen off), try to restart
audio.onstalled = ()=>{
  if(!audio.paused) setTimeout(()=>{ if(!audio.paused && audio.readyState < 3) audio.load(), audio.play().catch(()=>{}); }, 1500);
};
audio.onerror = ()=>{
  // Skip broken file automatically
  setTimeout(next, 500);
};

function updateEqState(paused){
  document.querySelectorAll(".song.active").forEach(el=>{
    el.classList.toggle("paused",paused);
  });
}

audio.ontimeupdate = ()=>{
  const cur = audio.currentTime, dur = audio.duration||0;
  if(!isSeeking){
    seek.max = dur; seek.value = cur;
    npSeek.max = dur; npSeek.value = cur;
  }
  const ct = formatTime(cur), dt = formatTime(dur);
  document.getElementById("curTime").textContent = ct;
  document.getElementById("durTime").textContent = dt;
  npCurTime.textContent = ct;
  npDurTime.textContent = dt;
  if(dur) miniProgressFill.style.width = (cur/dur*100)+"%";
  // Update lock screen progress bar every ~5 seconds to save battery
  if(Math.floor(cur) % 5 === 0) updatePositionState();
};

seek.addEventListener("input", ()=>{ isSeeking=true; audio.currentTime=seek.value; });
seek.addEventListener("change", ()=>{ isSeeking=false; });
npSeek.addEventListener("input", ()=>{ isSeeking=true; audio.currentTime=npSeek.value; });
npSeek.addEventListener("change", ()=>{ isSeeking=false; });

function setVolume(v){ audio.volume = v; }

function toggleShuffle(){ haptic(25); shuffle=!shuffle; updateControlStates(); }
function toggleRepeat(){ haptic(25); repeatMode=(repeatMode+1)%3; updateControlStates(); }

function updatePlayIcons(){
  const paused = audio.paused;
  const icon = paused ? "play" : "pause";
  [playBtn, npPlayBtn, miniPlayBtn].forEach(btn=>{
    if(!btn) return;
    btn.innerHTML = `<i data-lucide="${icon}"></i>`;
    lucide.createIcons();
  });
}

function updateControlStates(){
  shuffleBtn.classList.toggle("active-ctrl", shuffle);
  repeatBtn.classList.toggle("active-ctrl", repeatMode!==0);
  npShuffleBtn.classList.toggle("active", shuffle);
  npRepeatBtn.classList.toggle("active", repeatMode!==0);

  const rIcon = repeatMode===2?"repeat-1":"repeat";
  repeatBtn.innerHTML = `<i data-lucide="${rIcon}"></i>`;
  npRepeatBtn.innerHTML = `<i data-lucide="${rIcon}"></i>`;
  lucide.createIcons();
}

/* ================================================================
   MEDIA SESSION — full lock-screen controls + playback state
================================================================ */
if(navigator.mediaSession){
  // MUST be async — Chrome requires a Promise return so notification
  // buttons work reliably when the app is backgrounded
  navigator.mediaSession.setActionHandler("play", async ()=>{
    try { await audio.play(); setPlaybackState("playing"); } catch(e){}
  });
  navigator.mediaSession.setActionHandler("pause", ()=>{
    audio.pause();
    setPlaybackState("paused");
  });
  navigator.mediaSession.setActionHandler("stop", ()=>{
    audio.pause();
    setPlaybackState("none");
  });
  navigator.mediaSession.setActionHandler("nexttrack", next);
  navigator.mediaSession.setActionHandler("previoustrack", ()=>{ if(audio.currentTime>5) audio.currentTime=0; else prev(); });
  try {
    navigator.mediaSession.setActionHandler("seekto",       e=>{ if(e.seekTime != null) audio.currentTime = e.seekTime; });
    navigator.mediaSession.setActionHandler("seekforward",  e=>{ audio.currentTime = Math.min(audio.duration, audio.currentTime + (e.seekOffset||10)); });
    navigator.mediaSession.setActionHandler("seekbackward", e=>{ audio.currentTime = Math.max(0, audio.currentTime - (e.seekOffset||10)); });
  } catch(e){}
}

function setPlaybackState(state){
  // "playing" | "paused" | "none"
  // This is critical — it tells Android to keep the process alive
  if(navigator.mediaSession) navigator.mediaSession.playbackState = state;
}

// Update position state so lock screen progress bar works
function updatePositionState(){
  if(!navigator.mediaSession || !navigator.mediaSession.setPositionState) return;
  if(!audio.duration || isNaN(audio.duration)) return;
  try {
    navigator.mediaSession.setPositionState({
      duration:     audio.duration,
      playbackRate: audio.playbackRate,
      position:     audio.currentTime
    });
  } catch(e){}
}

/* ================================================================
   PRE-LOAD NEXT SONG URL — so next() works instantly off-screen
================================================================ */
// We pre-create the ObjectURL for the next song so that when the
// screen is off and audio.onended fires, next() can set audio.src
// synchronously without any async blob work — the browser allows this.
let preloadedUrls = {}; // { songId: objectUrl }

function preloadNextSong(){
  if(activePlaylist.length === 0) return;
  let nextIdx;
  if(shuffle){
    nextIdx = Math.floor(Math.random() * activePlaylist.length);
  } else if(repeatMode === 1){
    nextIdx = (currentIndex + 1) % activePlaylist.length;
  } else {
    nextIdx = currentIndex + 1;
  }
  if(nextIdx < 0 || nextIdx >= activePlaylist.length) return;
  const nextSong = activePlaylist[nextIdx];
  if(!nextSong || !nextSong.blob) return;
  if(preloadedUrls[nextSong.id]) return; // already pre-loaded
  // Revoke old pre-loaded URLs to free memory (keep only 2 ahead)
  Object.keys(preloadedUrls).forEach(id=>{
    if(id !== nextSong.id){ URL.revokeObjectURL(preloadedUrls[id]); delete preloadedUrls[id]; }
  });
  preloadedUrls[nextSong.id] = URL.createObjectURL(nextSong.blob);
}

function getOrCreateUrl(song){
  if(preloadedUrls[song.id]){
    const url = preloadedUrls[song.id];
    delete preloadedUrls[song.id]; // consume it
    return url;
  }
  return URL.createObjectURL(song.blob);
}

/* ================================================================
   SORT
================================================================ */
const sortLabels = ["Order","A–Z","Z–A"];
function cycleSortMode(){
  haptic(15);
  sortMode = (sortMode+1)%3;
  document.getElementById("sortLabel").textContent = sortLabels[sortMode];
  renderList();
}

/* ================================================================
   SEARCH
================================================================ */
function filterSongs(q){
  searchQuery = q.toLowerCase();
  document.getElementById("searchClear").style.display = q ? "flex" : "none";
  renderList();
}
function clearSearch(){
  document.getElementById("searchInput").value = "";
  filterSongs("");
}

/* ================================================================
   FAVOURITES (real DB playlist)
================================================================ */
function toggleFav(){
  haptic(20);
  if(!activePlaylist[currentIndex]) return;
  const songId = activePlaylist[currentIndex].id;
  const tx = db.transaction("playlists","readwrite");
  const st = tx.objectStore("playlists");
  st.get("favourites").onsuccess = e => {
    const p = e.target.result;
    if(!p) return;
    const idx = p.songIds.indexOf(songId);
    if(idx>=0){ p.songIds.splice(idx,1); st.put(p); }
    else { p.songIds.push(songId); st.put(p); }
    tx.oncomplete = ()=>{ loadAll(); updateFavUI(); toast(idx>=0?"Removed from Favourites":"Added to Favourites"); };
  };
}

function updateFavUI(){
  if(!activePlaylist[currentIndex]||!db) return;
  const songId = activePlaylist[currentIndex].id;
  const tx = db.transaction("playlists");
  tx.objectStore("playlists").get("favourites").onsuccess = e => {
    const p = e.target.result;
    const isFav = p ? p.songIds.includes(songId) : false;
    npFavBtn.classList.toggle("active",isFav);
    npFavBtn.innerHTML = `<i data-lucide="heart" style="fill:${isFav?"currentColor":"none"}"></i>`;
    lucide.createIcons();
  };
}

function switchToFavourites(){
  setTimeout(()=>{ activePlaylistId="favourites"; updatePlaylistBtn(); loadPlaylist("favourites"); },150);
}

/* ================================================================
   NOW PLAYING PANEL
================================================================ */
function openNowPlaying(){
  document.getElementById("nowPlaying").classList.add("open");
}
function closeNowPlaying(){
  document.getElementById("nowPlaying").classList.remove("open");
}

// swipe down to close
const np = document.getElementById("nowPlaying");
np.addEventListener("touchstart", e=>{ npSwipeStartY = e.touches[0].clientY; },{passive:true});
np.addEventListener("touchmove", e=>{
  const dy = e.touches[0].clientY - npSwipeStartY;
  if(dy>0) np.style.transform=`translateY(${dy}px)`;
},{passive:true});
np.addEventListener("touchend", e=>{
  const dy = e.changedTouches[0].clientY - npSwipeStartY;
  np.style.transform="";
  if(dy>100) closeNowPlaying();
},{passive:true});

/* ================================================================
   MULTI-SELECT
================================================================ */
function enterMultiSelect(songId){
  multiSelectMode = true;
  selectedIds.clear();
  if(songId) selectedIds.add(songId);
  list.classList.add("multiselect-active");
  document.getElementById("multiselectBar").classList.add("active");
  updateMultiselectCount();
  renderList();
}

function exitMultiSelect(){
  multiSelectMode = false;
  selectedIds.clear();
  list.classList.remove("multiselect-active");
  document.getElementById("multiselectBar").classList.remove("active");
  renderList();
}

function toggleSongSelection(id, rowEl, chkEl){
  if(selectedIds.has(id)){
    selectedIds.delete(id);
    rowEl.classList.remove("selected");
    chkEl.innerHTML = "";
  } else {
    selectedIds.add(id);
    rowEl.classList.add("selected");
    chkEl.innerHTML = '<i data-lucide="check" style="width:12px;height:12px"></i>';
    lucide.createIcons();
  }
  updateMultiselectCount();
}

function updateMultiselectCount(){
  const n = selectedIds.size;
  document.getElementById("multiselectCount").textContent = n + " selected";
}

function multiDelete(){
  if(!selectedIds.size){ toast("No songs selected"); return; }
  const n = selectedIds.size;
  openConfirmModal(`Move ${n} song${n!==1?"s":""} to Trash?`, "Songs can be restored from Trash within 10 days.", ()=>{
    const ids = [...selectedIds];
    ids.forEach(id => moveToTrash(id, false));
    // batch save
    const tx = db.transaction(["songs","playlists","trash"],"readwrite");
    const sStore = tx.objectStore("songs");
    const tStore = tx.objectStore("trash");
    const pStore = tx.objectStore("playlists");
    const now = Date.now();
    ids.forEach(id=>{
      const song = songs[id];
      if(!song) return;
      tStore.put({...song, deletedAt: now});
      sStore.delete(id);
    });
    pStore.openCursor().onsuccess = ev => {
      const c = ev.target.result;
      if(c){ c.value.songIds = c.value.songIds.filter(x=>!ids.includes(x)); pStore.put(c.value); c.continue(); }
    };
    if(currentIndex>=0 && ids.includes(activePlaylist[currentIndex]?.id)){
      audio.pause(); audio.src=""; currentIndex=-1; miniPlayer.classList.add("hidden");
    }
    tx.oncomplete = ()=>{
      loadAll(); updateTrashBadge();
      toast(`${n} song${n!==1?"s":""} moved to Trash`);
    };
    exitMultiSelect();
  }, "Move to Trash");
}

function multiAddToPlaylist(){
  if(!selectedIds.size){ toast("No songs selected"); return; }
  const targets = Object.values(playlists).filter(p=>p.id!==activePlaylistId&&p.id!=="all");
  if(!targets.length){ toast("No playlists available. Create one first."); return; }
  let html = '';
  targets.forEach(p=>{
    const isFav = p.id==="favourites";
    html += `<div class="modal-list-item" onclick="multiAddToPlaylistConfirm('${p.id}')">
      <div class="modal-list-item-icon" style="${isFav?"color:#ff6b8a":""}"><i data-lucide="${isFav?"heart":"music"}"></i></div>
      <span>${p.name}</span>
    </div>`;
  });
  openModal(`Add ${selectedIds.size} songs to…`, html, null, null, "Cancel");
  setTimeout(()=>lucide.createIcons(),50);
}

function multiAddToPlaylistConfirm(playlistId){
  closeModal();
  const ids = [...selectedIds];
  const tx = db.transaction("playlists","readwrite");
  tx.objectStore("playlists").get(playlistId).onsuccess = e => {
    const p = e.target.result;
    ids.forEach(id=>{ if(!p.songIds.includes(id)) p.songIds.push(id); });
    tx.objectStore("playlists").put(p);
  };
  tx.oncomplete = ()=>{ loadAll(); toast(`Added ${ids.length} songs`); exitMultiSelect(); };
}

/* ================================================================
   TRASH SYSTEM
================================================================ */
const TRASH_EXPIRY_MS = 10 * 24 * 60 * 60 * 1000; // 10 days

// Trash multi-select state
let trashMultiMode = false;
let trashSelectedIds = new Set();
let trashItems = []; // current loaded items cache

function moveToTrash(id, doLoadAll=true){
  const song = songs[id];
  if(!song) return;
  const now = Date.now();
  const tx = db.transaction(["songs","playlists","trash"],"readwrite");
  tx.objectStore("trash").put({...song, deletedAt: now});
  tx.objectStore("songs").delete(id);
  tx.objectStore("playlists").openCursor().onsuccess = e => {
    const c = e.target.result;
    if(c){ c.value.songIds = c.value.songIds.filter(x=>x!==id); e.target.source.put(c.value); c.continue(); }
  };
  if(currentIndex>=0 && activePlaylist[currentIndex]?.id===id){
    audio.pause(); audio.src=""; currentIndex=-1; miniPlayer.classList.add("hidden");
  }
  if(doLoadAll) tx.oncomplete = ()=>{ loadAll(); updateTrashBadge(); toast("Moved to Trash"); };
}

function updateTrashBadge(){
  const tx = db.transaction("trash");
  const now = Date.now();
  let count = 0;
  tx.objectStore("trash").openCursor().onsuccess = e => {
    const c = e.target.result;
    if(c){
      if(now - c.value.deletedAt < TRASH_EXPIRY_MS) count++;
      else db.transaction("trash","readwrite").objectStore("trash").delete(c.value.id);
      c.continue();
    } else {
      const badge = document.getElementById("trashBadge");
      if(badge){ badge.style.display = count ? "inline-flex":"none"; badge.textContent = count>99?"99+":count; }
    }
  };
}

function openTrashView(){
  trashMultiMode = false;
  trashSelectedIds.clear();
  document.getElementById("trashOverlay").classList.add("open");
  renderTrashList();
  lucide.createIcons();
}
function closeTrashView(){
  stopTrashPreview();
  exitTrashMultiSelect();
  document.getElementById("trashOverlay").classList.remove("open");
}
document.getElementById("trashOverlay").addEventListener("click",e=>{
  if(e.target===document.getElementById("trashOverlay")) closeTrashView();
});

/* ── Trash multi-select controls ── */
function enterTrashMultiSelect(id){
  trashMultiMode = true;
  trashSelectedIds.clear();
  if(id) trashSelectedIds.add(id);
  document.getElementById("trashMultibar").classList.add("active");
  document.getElementById("trashHeader").style.display = "none";
  document.getElementById("trashList").classList.add("trash-multiactive");
  updateTrashMultiCount();
  // re-render rows to show checkboxes
  _refreshTrashCheckboxes();
}

function exitTrashMultiSelect(){
  trashMultiMode = false;
  trashSelectedIds.clear();
  document.getElementById("trashMultibar").classList.remove("active");
  document.getElementById("trashHeader").style.display = "";
  document.getElementById("trashList").classList.remove("trash-multiactive");
  _refreshTrashCheckboxes();
}

function updateTrashMultiCount(){
  const n = trashSelectedIds.size;
  document.getElementById("trashMultiCount").textContent = n + " selected";
}

function trashSelectAll(){
  trashItems.forEach(item => trashSelectedIds.add(item.id));
  updateTrashMultiCount();
  _refreshTrashCheckboxes();
}

function _refreshTrashCheckboxes(){
  document.querySelectorAll(".trash-item[data-tid]").forEach(row => {
    const id = row.dataset.tid;
    const chk = row.querySelector(".t-checkbox");
    const sel = trashSelectedIds.has(id);
    row.classList.toggle("t-selected", sel);
    if(chk) chk.innerHTML = sel ? '<i data-lucide="check" style="width:12px;height:12px"></i>' : '';
  });
  lucide.createIcons();
}

function _toggleTrashItem(id, rowEl){
  const chk = rowEl.querySelector(".t-checkbox");
  if(trashSelectedIds.has(id)){
    trashSelectedIds.delete(id);
    rowEl.classList.remove("t-selected");
    if(chk) chk.innerHTML = '';
  } else {
    trashSelectedIds.add(id);
    rowEl.classList.add("t-selected");
    if(chk){ chk.innerHTML='<i data-lucide="check" style="width:12px;height:12px"></i>'; lucide.createIcons(); }
  }
  updateTrashMultiCount();
}

function trashMultiRestore(){
  if(!trashSelectedIds.size){ toast("Nothing selected"); return; }
  const ids = [...trashSelectedIds];
  const tx = db.transaction(["songs","playlists","trash"],"readwrite");
  const pStore = tx.objectStore("playlists");
  const sStore = tx.objectStore("songs");
  const tStore = tx.objectStore("trash");
  // get All Songs playlist once
  pStore.get("all").onsuccess = e => {
    const all = e.target.result;
    ids.forEach(id => {
      tStore.get(id).onsuccess = ev => {
        const item = ev.target.result;
        if(!item) return;
        const song = {...item}; delete song.deletedAt;
        sStore.put(song);
        tStore.delete(id);
        if(!all.songIds.includes(id)) all.songIds.push(id);
      };
    });
    pStore.put(all);
  };
  tx.oncomplete = ()=>{ loadAll(); updateTrashBadge(); exitTrashMultiSelect(); renderTrashList(); toast(`Restored ${ids.length} song${ids.length!==1?"s":""}`); };
}

function trashMultiDelete(){
  if(!trashSelectedIds.size){ toast("Nothing selected"); return; }
  const n = trashSelectedIds.size;
  openConfirmModal(`Delete ${n} song${n!==1?"s":""} permanently?`,"This cannot be undone.",()=>{
    const ids = [...trashSelectedIds];
    const tx = db.transaction("trash","readwrite");
    ids.forEach(id => tx.objectStore("trash").delete(id));
    tx.oncomplete = ()=>{ updateTrashBadge(); exitTrashMultiSelect(); renderTrashList(); toast(`Deleted ${n} song${n!==1?"s":""}`); };
  });
}

let trashPreviewId = null; // id of song currently previewing in trash

function renderTrashList(){
  const el = document.getElementById("trashList");
  if(!el) return;
  el.innerHTML = "";
  const now = Date.now();
  const tx = db.transaction("trash");
  trashItems = [];
  tx.objectStore("trash").openCursor().onsuccess = e => {
    const c = e.target.result;
    if(c){
      if(now - c.value.deletedAt < TRASH_EXPIRY_MS) trashItems.push(c.value);
      c.continue();
    } else {
      if(!trashItems.length){
        el.innerHTML='<div style="text-align:center;padding:40px 24px;color:var(--muted)"><i data-lucide="trash-2" style="width:40px;height:40px;opacity:.3;display:block;margin:0 auto 12px"></i>Trash is empty</div>';
        lucide.createIcons();
        document.getElementById("emptyTrashBtn").style.display="none";
        return;
      }
      document.getElementById("emptyTrashBtn").style.display="";
      trashItems.sort((a,b)=>b.deletedAt-a.deletedAt);

      trashItems.forEach(item => {
        const daysLeft = Math.ceil((TRASH_EXPIRY_MS-(now-item.deletedAt))/86400000);
        const cleanName = item.name.replace(/\.[^.]+$/,"");
        const isSelected = trashSelectedIds.has(item.id);

        const row = document.createElement("div");
        row.className = "trash-item" + (isSelected?" t-selected":"");
        row.dataset.tid = item.id;

        // checkbox (hidden via CSS until .trash-multiactive on parent)
        const chk = document.createElement("div");
        chk.className = "t-checkbox";
        if(isSelected) chk.innerHTML = '<i data-lucide="check" style="width:12px;height:12px"></i>';

        // info
        const info = document.createElement("div");
        info.className = "trash-item-info";
        info.innerHTML = `<div class="trash-item-name">${cleanName}</div><div class="trash-item-sub">${daysLeft}d left · ${item.name.split(".").pop().toUpperCase()}</div>`;

        // preview play/stop button
        const previewBtn = document.createElement("button");
        previewBtn.className = "trash-item-preview";
        previewBtn.dataset.pid = item.id;
        previewBtn.innerHTML = trashPreviewId===item.id
          ? '<i data-lucide="square" style="width:13px;height:13px"></i>'
          : '<i data-lucide="play" style="width:13px;height:13px"></i>';
        previewBtn.onclick = ev => {
          ev.stopPropagation();
          toggleTrashPreview(item);
        };

        // restore button
        const restoreBtn = document.createElement("button");
        restoreBtn.className = "trash-item-restore";
        restoreBtn.textContent = "Restore";
        restoreBtn.onclick = ev => { ev.stopPropagation(); restoreFromTrash(item.id); };

        // permanent delete button
        const delBtn = document.createElement("button");
        delBtn.className = "trash-item-del";
        delBtn.innerHTML = '<i data-lucide="x" style="width:12px;height:12px"></i>';
        delBtn.onclick = ev => { ev.stopPropagation(); permanentDelete(item.id); };

        row.append(chk, info, previewBtn, restoreBtn, delBtn);

        // ── Long-press logic ──
        // We use a single pressTimer and a longPressFired flag per row.
        // On mobile: touchstart starts timer, touchend/move cancel it.
        //   After long-press fires we set longPressFired=true so the
        //   subsequent 'click' event (which browsers fire after touchend)
        //   is ignored for selection/toggle.
        // On desktop: mousedown starts timer, mouseup cancels it.
        //   onclick handles normal tap/click.

        let pressTimer = null;
        let longPressFired = false;

        function doLongPress(){
          longPressFired = true;
          haptic(40);
          if(!trashMultiMode){
            enterTrashMultiSelect(item.id);
          } else {
            _toggleTrashItem(item.id, row);
          }
        }

        // Touch events
        row.addEventListener("touchstart", ev => {
          // only if not tapping a button inside
          if(ev.target.closest("button")) return;
          longPressFired = false;
          pressTimer = setTimeout(doLongPress, 500);
        }, {passive:true});

        row.addEventListener("touchmove", () => {
          clearTimeout(pressTimer);
          pressTimer = null;
        }, {passive:true});

        row.addEventListener("touchend", () => {
          clearTimeout(pressTimer);
          pressTimer = null;
          // don't do anything here — click event will fire naturally for short taps
        }, {passive:true});

        // Click (fires after touchend on mobile, or direct click on desktop)
        row.addEventListener("click", ev => {
          if(ev.target.closest("button")) return; // buttons handle themselves
          if(longPressFired){ longPressFired = false; return; } // skip — long press already handled
          if(trashMultiMode){
            _toggleTrashItem(item.id, row);
          }
          // normal mode: do nothing on row click (preview/restore buttons handle actions)
        });

        // Mouse long-press for desktop (no touch)
        row.addEventListener("mousedown", ev => {
          if(ev.button !== 0) return;
          if(ev.target.closest("button")) return;
          longPressFired = false;
          pressTimer = setTimeout(doLongPress, 600);
        });
        row.addEventListener("mouseup", () => { clearTimeout(pressTimer); pressTimer = null; });
        row.addEventListener("mouseleave", () => { clearTimeout(pressTimer); pressTimer = null; });

        el.appendChild(row);
      });

      lucide.createIcons();
    }
  };
}

// ── Trash preview ──
let trashPreviewAudio = null;
let trashPreviewSeeking = false;

function toggleTrashPreview(item){
  if(trashPreviewId === item.id){
    trashPreviewToggle(); // play/pause same song
    return;
  }
  stopTrashPreview(false);
  trashPreviewId = item.id;

  // Pause main player
  if(!audio.paused) audio.pause();

  trashPreviewAudio = new Audio();
  const url = URL.createObjectURL(item.blob);
  trashPreviewAudio.src = url;
  trashPreviewAudio.volume = audio.volume;
  trashPreviewAudio.play().catch(()=>{});
  trashPreviewAudio.onended = () => stopTrashPreview();

  // Show bar
  const bar = document.getElementById("trashPreviewBar");
  const title = document.getElementById("trashPreviewTitle");
  const seek = document.getElementById("trashPreviewSeek");
  bar.classList.add("visible");
  title.textContent = item.name.replace(/\.[^.]+$/,"");
  seek.value = 0;

  // Time & seek updates
  trashPreviewAudio.ontimeupdate = () => {
    if(trashPreviewSeeking) return;
    const cur = trashPreviewAudio.currentTime, dur = trashPreviewAudio.duration||0;
    seek.max = dur; seek.value = cur;
    document.getElementById("trashPreviewTime").textContent = formatTime(cur)+" / "+formatTime(dur);
    document.getElementById("trashPreviewPlayBtn").innerHTML =
      `<i data-lucide="${trashPreviewAudio.paused?"play":"pause"}" style="width:16px;height:16px"></i>`;
    lucide.createIcons();
  };

  // Update row icon
  _updateTrashPreviewIcons();
}

function trashPreviewToggle(){
  if(!trashPreviewAudio) return;
  if(trashPreviewAudio.paused){
    trashPreviewAudio.play();
  } else {
    trashPreviewAudio.pause();
  }
  document.getElementById("trashPreviewPlayBtn").innerHTML =
    `<i data-lucide="${trashPreviewAudio.paused?"play":"pause"}" style="width:16px;height:16px"></i>`;
  lucide.createIcons();
}

function trashPreviewStop(){
  stopTrashPreview();
}

function stopTrashPreview(updateIcon=true){
  if(trashPreviewAudio){
    trashPreviewAudio.pause();
    trashPreviewAudio.ontimeupdate = null;
    URL.revokeObjectURL(trashPreviewAudio.src);
    trashPreviewAudio = null;
  }
  document.getElementById("trashPreviewBar")?.classList.remove("visible");
  if(updateIcon) _updateTrashPreviewIcons();
  trashPreviewId = null;
}

function _updateTrashPreviewIcons(){
  // update all row preview buttons
  document.querySelectorAll(".trash-item-preview[data-pid]").forEach(btn=>{
    const isActive = btn.dataset.pid === trashPreviewId;
    btn.innerHTML = isActive
      ? '<i data-lucide="square" style="width:13px;height:13px"></i>'
      : '<i data-lucide="play" style="width:13px;height:13px"></i>';
  });
  lucide.createIcons();
}

// Seek bar interaction
document.getElementById("trashPreviewSeek")?.addEventListener("input", e=>{
  trashPreviewSeeking = true;
  if(trashPreviewAudio) trashPreviewAudio.currentTime = +e.target.value;
});
document.getElementById("trashPreviewSeek")?.addEventListener("change", ()=>{ trashPreviewSeeking = false; });

function restoreFromTrash(id){
  const tx = db.transaction(["songs","playlists","trash"],"readwrite");
  tx.objectStore("trash").get(id).onsuccess = e => {
    const item = e.target.result; if(!item) return;
    const song = {...item}; delete song.deletedAt;
    tx.objectStore("songs").put(song);
    tx.objectStore("trash").delete(id);
    tx.objectStore("playlists").get("all").onsuccess = ev => {
      const all = ev.target.result;
      if(!all.songIds.includes(id)) all.songIds.push(id);
      tx.objectStore("playlists").put(all);
    };
  };
  tx.oncomplete = ()=>{ loadAll(); updateTrashBadge(); renderTrashList(); toast("Restored"); };
}

function permanentDelete(id){
  openConfirmModal("Delete permanently?","This cannot be undone.",()=>{
    const tx = db.transaction("trash","readwrite");
    tx.objectStore("trash").delete(id);
    tx.oncomplete = ()=>{ updateTrashBadge(); renderTrashList(); toast("Permanently deleted"); };
  });
}

function emptyTrash(){
  openConfirmModal("Empty Trash?","All trashed songs will be permanently deleted.",()=>{
    const tx = db.transaction("trash","readwrite");
    tx.objectStore("trash").clear();
    tx.oncomplete = ()=>{ updateTrashBadge(); exitTrashMultiSelect(); renderTrashList(); toast("Trash emptied"); };
  });
}

/* ================================================================
   CONTEXT MENU
================================================================ */
function openCtxMenu(e, songId){
  haptic(15);
  contextSongId = songId;
  const menu = document.getElementById("ctxMenu");
  // Only show "Refresh gradient" if the song has no embedded artwork
  const hasRealArt = !!artworkCache[songId];
  document.getElementById("ctxRefreshGrad").style.display = hasRealArt ? "none" : "flex";
  menu.classList.add("open");
  // position — keep within screen
  const x = Math.min(e.clientX, window.innerWidth-200);
  const y = Math.min(e.clientY, window.innerHeight-220);
  menu.style.left = x+"px";
  menu.style.top = y+"px";
}
function closeCtxMenu(){ document.getElementById("ctxMenu").classList.remove("open"); }
document.addEventListener("click", closeCtxMenu);
document.getElementById("ctxRefreshGrad").onclick = e => {
  e.stopPropagation(); closeCtxMenu();
  const song = songs[contextSongId];
  if(!song) return;
  // Bump seed by a large random amount so colour changes noticeably
  gradientSeeds[contextSongId] = ((gradientSeeds[contextSongId]||0) + 40 + Math.floor(Math.random()*200)) % 360;
  localStorage.setItem("bpGradSeeds", JSON.stringify(gradientSeeds));
  haptic(15);

  // Redraw thumbnail in list without full re-render
  const filtered = getFilteredSorted();
  const fi = filtered.findIndex(s=>s&&s.id===contextSongId);
  if(fi >= 0){
    const row = list.querySelectorAll(".song")[fi];
    if(row){
      const c = row.querySelector(".song-art-mini-canvas");
      if(c) drawFallbackCanvas(c.getContext("2d"), song.name, 44, 44, song.id);
    }
  }

  // If this is the currently playing song, also refresh now-playing art + backdrop
  if(currentIndex >= 0 && activePlaylist[currentIndex]?.id === contextSongId){
    const npC = document.getElementById("npArtCanvas");
    const miniC = document.getElementById("miniArtCanvas");
    drawFallbackCanvas(npC.getContext("2d"), song.name, 512, 512, song.id);
    drawFallbackCanvas(miniC.getContext("2d"), song.name, 46, 46, song.id);
    const base = [...song.name].reduce((a,c)=>a+c.charCodeAt(0),0);
    const seed = gradientSeeds[song.id]||0;
    const bh1=(base+seed)%360, bh2=(base*137+seed*73)%360;
    npBackdrop.style.backgroundImage="none";
    npBackdrop.style.background=`linear-gradient(135deg,hsl(${bh1},65%,25%),hsl(${bh2},65%,15%))`;
  }
  toast("New gradient applied");
};
document.getElementById("ctxSelect").onclick = e => {
  e.stopPropagation(); closeCtxMenu();
  enterMultiSelect(contextSongId);
};
document.getElementById("ctxPlay").onclick = e => {
  e.stopPropagation();
  const i = activePlaylist.findIndex(s=>s.id===contextSongId);
  if(i>=0) play(i); closeCtxMenu();
};
document.getElementById("ctxAddPlaylist").onclick = e => {
  e.stopPropagation(); closeCtxMenu();
  openPlaylistPickerModal(contextSongId);
};
document.getElementById("ctxDownload").onclick = e => {
  e.stopPropagation(); closeCtxMenu();
  downloadSong(songs[contextSongId]);
};
document.getElementById("ctxDelete").onclick = e => {
  e.stopPropagation(); closeCtxMenu();
  openConfirmModal("Move to Trash?","You can restore it within 10 days.",()=>{
    moveToTrash(contextSongId);
  }, "Move to Trash");
};

/* ================================================================
   MODALS
================================================================ */
const modalOverlay = document.getElementById("modalOverlay");
const modal = document.getElementById("modal");

function openModal(title, bodyHTML, onConfirm, confirmLabel, cancelLabel){
  document.getElementById("modalTitle").textContent = title;
  document.getElementById("modalBody").innerHTML = bodyHTML;
  const actions = document.createElement("div");
  actions.className = "modal-actions";
  if(cancelLabel){
    const b=document.createElement("button"); b.className="chip-btn"; b.textContent=cancelLabel;
    b.style.cssText="height:48px;border-radius:14px;font-size:15px;font-weight:600;flex:1";
    b.onclick=closeModal; actions.appendChild(b);
  }
  if(confirmLabel && onConfirm){
    const b=document.createElement("button"); b.className="chip-btn primary"; b.textContent=confirmLabel;
    b.style.cssText="height:48px;border-radius:14px;font-size:15px;font-weight:600;flex:1";
    b.onclick=()=>{ closeModal(); onConfirm(); }; actions.appendChild(b);
  }
  if(actions.children.length) document.getElementById("modalBody").appendChild(actions);
  modalOverlay.classList.add("open");
}

function openConfirmModal(title, msg, onConfirm, confirmLabel="Delete"){
  openModal(title, `<p style="padding:0 24px 8px;color:var(--muted);font-size:14px">${msg}</p>`, onConfirm, confirmLabel, "Cancel");
}

function closeModal(){
  modalOverlay.classList.remove("open");
}
modalOverlay.onclick = e => { if(e.target===modalOverlay) closeModal(); };

function openPlaylistPickerModal(songId){
  const targets = Object.values(playlists).filter(p=>p.id!==activePlaylistId);
  if(!targets.length){ toast("No other playlists available."); return; }
  let html = '';
  targets.forEach(p=>{
    const isFav = p.id==="favourites";
    html += `<div class="modal-list-item" onclick="addToPlaylistAndClose('${p.id}','${songId}')">
      <div class="modal-list-item-icon" style="${isFav?"color:#ff6b8a":""}"><i data-lucide="${isFav?"heart":"music"}"></i></div>
      <span>${p.name}</span>
    </div>`;
  });
  openModal("Add to Playlist", html, null, null, "Cancel");
  setTimeout(()=>lucide.createIcons(),50);
}

function addToPlaylistAndClose(playlistId, songId){
  closeModal();
  const tx = db.transaction("playlists","readwrite");
  const store = tx.objectStore("playlists");
  store.get(playlistId).onsuccess = e => {
    const p = e.target.result;
    if(!p.songIds.includes(songId)){ p.songIds.push(songId); store.put(p); }
  };
  tx.oncomplete = ()=>{ loadAll(); toast("Added to playlist"); };
}

/* ================================================================
   PLAYLIST MANAGEMENT
================================================================ */
function createPlaylist(){
  haptic(20);
  openModal("New Playlist",
    `<input type="text" id="newPlaylistName" placeholder="Playlist name…" maxlength="40" style="margin-bottom:0">`,
    ()=>{
      const n = document.getElementById("newPlaylistName").value.trim();
      if(!n){ toast("Enter a name"); return; }
      const tx = db.transaction("playlists","readwrite");
      tx.objectStore("playlists").put({id:crypto.randomUUID(),name:n,songIds:[]});
      tx.oncomplete = ()=>{ loadAll(); toast("Playlist created"); };
    }, "Create"
  );
  setTimeout(()=>document.getElementById("newPlaylistName")?.focus(),200);
}

function deletePlaylist(){
  haptic(30);
  if(activePlaylistId==="all"){
    openConfirmModal("Clear all songs?","This cannot be undone.",()=>{
      audio.pause(); audio.src=""; currentIndex=-1;
      const tx = db.transaction(["songs","playlists"],"readwrite");
      tx.objectStore("songs").clear();
      const pStore = tx.objectStore("playlists");
      pStore.openCursor().onsuccess = e => {
        const c = e.target.result;
        if(c){
          if(c.value.id==="all"||c.value.id==="favourites"){ c.value.songIds=[]; pStore.put(c.value); }
          else pStore.delete(c.value.id);
          c.continue();
        }
      };
      tx.oncomplete = ()=>{ miniPlayer.classList.add("hidden"); loadAll(); };
    });
    return;
  }
  if(activePlaylistId==="favourites"){
    openConfirmModal("Clear Favourites?","Songs stay in your library.",()=>{
      const tx = db.transaction("playlists","readwrite");
      tx.objectStore("playlists").get("favourites").onsuccess = e=>{
        const p=e.target.result; p.songIds=[]; tx.objectStore("playlists").put(p);
      };
      activePlaylistId="all"; tx.oncomplete=loadAll;
    },"Clear");
    return;
  }
  openConfirmModal(`Delete "${playlists[activePlaylistId]?.name}"?`,"Songs stay in All Songs.",()=>{
    const tx = db.transaction("playlists","readwrite");
    tx.objectStore("playlists").delete(activePlaylistId);
    activePlaylistId = "all";
    tx.oncomplete = loadAll;
  });
}

function savePlaylistOrder(){
  if(activePlaylistId==="all"){
    const tx=db.transaction("playlists","readwrite");
    tx.objectStore("playlists").get("all").onsuccess=e=>{
      const p=e.target.result; p.songIds=activePlaylist.map(s=>s.id); tx.objectStore("playlists").put(p);
    };
    return;
  }
  const tx=db.transaction("playlists","readwrite");
  tx.objectStore("playlists").get(activePlaylistId).onsuccess=e=>{
    const p=e.target.result; p.songIds=activePlaylist.map(s=>s.id); tx.objectStore("playlists").put(p);
  };
}

function removeFromPlaylist(id){
  haptic(30);
  const tx=db.transaction("playlists","readwrite");
  tx.objectStore("playlists").get(activePlaylistId).onsuccess=e=>{
    const p=e.target.result; p.songIds=p.songIds.filter(x=>x!==id);
    tx.objectStore("playlists").put(p);
  };
  tx.oncomplete=loadAll;
}

function deleteSongEverywhere(id){
  haptic(30);
  const tx=db.transaction(["songs","playlists"],"readwrite");
  tx.objectStore("songs").delete(id);
  tx.objectStore("playlists").openCursor().onsuccess=e=>{
    const c=e.target.result;
    if(c){ c.value.songIds=c.value.songIds.filter(x=>x!==id); e.target.source.put(c.value); c.continue(); }
  };
  if(currentIndex>=0 && activePlaylist[currentIndex]?.id===id){
    audio.pause(); audio.src=""; currentIndex=-1; miniPlayer.classList.add("hidden");
  }
  tx.oncomplete=loadAll;
}

/* ================================================================
   FILE ADD
================================================================ */
function pickFiles(){
  haptic(20);
  const input = document.createElement("input");
  input.type="file"; input.multiple=true; input.accept="audio/*,video/mp4";
  input.onchange = ()=>{
    const tx=db.transaction(["songs","playlists"],"readwrite");
    const s=tx.objectStore("songs"), p=tx.objectStore("playlists");
    p.get("all").onsuccess=e=>{
      const all=e.target.result;
      const target=playlists[activePlaylistId];
      const files=[...input.files];
      files.forEach(f=>{
        const id=crypto.randomUUID();
        s.put({id,name:f.name,blob:f,duration:0});
        all.songIds.push(id);
        if(activePlaylistId!=="all"&&target) target.songIds.push(id);
      });
      p.put(all);
      if(activePlaylistId!=="all"&&target) p.put(target);
    };
    tx.oncomplete=()=>{ loadAll(); toast(`Added ${input.files.length} song${input.files.length!==1?"s":""}!`); };
  };
  input.click();
}

/* ================================================================
   DOWNLOAD
================================================================ */
function downloadSong(song){
  if(!song?.blob){ toast("File not available"); return; }
  const url=URL.createObjectURL(song.blob);
  const a=document.createElement("a");
  a.href=url; a.download=song.name;
  document.body.appendChild(a); a.click(); a.remove();
  setTimeout(()=>URL.revokeObjectURL(url),1000);
  toast("Downloading…");
}

/* ================================================================
   SLEEP TIMER
================================================================ */
function openSleepPanel(){ document.getElementById("sleepPanel").classList.add("open"); }
function closeSleepPanel(){ document.getElementById("sleepPanel").classList.remove("open"); }

function startSleepTimer(){
  const min = Math.max(1, Math.min(60, +sleepInput.value||0));
  clearInterval(sleepTimerInterval);
  sleepTotal = min*60*1000;
  sleepEndTime = Date.now()+sleepTotal;
  localStorage.setItem("sleepEnd", sleepEndTime);
  updateSleepUI();
  sleepTimerInterval = setInterval(updateSleepUI, 1000);
  toast(`Sleep timer: ${min} min`);
}
function cancelSleepTimer(){
  clearInterval(sleepTimerInterval); sleepTimerInterval=null;
  sleepEndTime=0; sleepTotal=0;
  localStorage.removeItem("sleepEnd");
  sleepCountdown.textContent="--:--";
  sleepProgress.style.strokeDashoffset=239;
  toast("Sleep timer cancelled");
}
function updateSleepUI(){
  const rem = sleepEndTime - Date.now();
  if(rem<=0){
    clearInterval(sleepTimerInterval); sleepTimerInterval=null;
    localStorage.removeItem("sleepEnd");
    audio.pause(); toast("Sleep timer ended"); return;
  }
  const sec=Math.floor(rem/1000);
  const m=String(Math.floor(sec/60)).padStart(2,"0");
  const s=String(sec%60).padStart(2,"0");
  sleepCountdown.textContent=`${m}:${s}`;
  sleepProgress.style.strokeDashoffset = 239*(1-rem/sleepTotal);
}
// restore
const savedSleep = +localStorage.getItem("sleepEnd");
if(savedSleep && savedSleep>Date.now()){
  sleepEndTime=savedSleep; sleepTotal=savedSleep-Date.now();
  updateSleepUI(); sleepTimerInterval=setInterval(updateSleepUI,1000);
}

/* ================================================================
   TOAST
================================================================ */
let toastTimer;
function toast(msg){
  const t=document.getElementById("toast");
  t.textContent=msg; t.classList.add("show");
  clearTimeout(toastTimer);
  toastTimer=setTimeout(()=>t.classList.remove("show"),2200);
}

/* ================================================================
   MISC
================================================================ */
function formatTime(sec){
  if(!sec||isNaN(sec)) return "0:00";
  const m=Math.floor(sec/60), s=Math.floor(sec%60).toString().padStart(2,"0");
  return `${m}:${s}`;
}
function openConverter(){ window.location.href="https://beast-beats.github.io/Beast_Convertor/"; }
async function shareCurrentSong(){
  if(!activePlaylist[currentIndex]){ toast("Nothing playing"); return; }
  const song = activePlaylist[currentIndex];
  if(!song.blob){ toast("File not available"); return; }
  try {
    const file = new File([song.blob], song.name, {type:song.blob.type||"audio/mpeg"});
    if(navigator.share && navigator.canShare && navigator.canShare({files:[file]})){
      await navigator.share({title:"Beast Player", files:[file]});
    } else if(navigator.share){
      await navigator.share({title:"Beast Player", text:song.name.replace(/\.[^.]+$/,"")});
    } else {
      downloadSong(song); toast("Sharing not supported — downloading instead");
    }
  } catch(e){ if(e.name!=="AbortError") toast("Could not share"); }
}
function showAboutModal(){
  openModal("Beast Player",
    `<p style="padding:0 24px 16px;color:var(--muted);font-size:14px;line-height:1.6">
      Offline music player. All your music, stored locally on your device.<br><br>
      Made with ❤️ by <strong style="color:var(--text)">Beast_Beats</strong>.
    </p>`, null, null, "Close");
}

/* ================================================================
   INIT
================================================================ */
lucide.createIcons();
updateControlStates();

/* ================================================================
   BACKGROUND AUDIO ENGINE
   Three-layer system to keep Chrome alive when screen is off:

   Layer 1 — Silent AudioContext oscillator
     Plays a 0-amplitude (truly silent, no sound) tone via Web Audio.
     Android sees an active AudioContext and gives Chrome the same
     high-priority "music app" process treatment. This is the most
     effective technique available to a PWA.

   Layer 2 — Service Worker keepalive ping every 20 s
     Keeps the SW process alive, which in turn keeps the tab alive.

   Layer 3 — Watchdog timer catches stuck playback
     If a song somehow doesn't auto-advance, a watchdog catches it.
================================================================ */

// ── Layer 1: Silent AudioContext ──────────────────────────────────────────
let bgAudioCtx   = null;
let bgOscillator = null;
let bgGain       = null;

function startSilentAudio(){
  if(bgAudioCtx && bgAudioCtx.state === "running") return;
  try {
    // Close any existing context before creating a new one
    if(bgAudioCtx){ try { bgAudioCtx.close(); } catch(e){} bgAudioCtx = null; }

    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    bgAudioCtx = ctx;

    // Gain set to near-zero — completely inaudible, no sound whatsoever
    bgGain = ctx.createGain();
    bgGain.gain.setValueAtTime(0.000001, ctx.currentTime);
    bgGain.connect(ctx.destination);

    // Oscillator — any frequency, totally silent at zero gain
    bgOscillator = ctx.createOscillator();
    bgOscillator.type = "sine";
    bgOscillator.frequency.setValueAtTime(440, ctx.currentTime);
    bgOscillator.connect(bgGain);
    bgOscillator.start();

    // If context gets suspended by browser, resume it.
    // Use the local `ctx` reference — never reads bgAudioCtx which may be null.
    ctx.addEventListener("statechange", ()=>{
      if(ctx.state === "suspended" && !audio.paused){
        ctx.resume().catch(()=>{});
      }
    });
  } catch(e){}
}

function stopSilentAudio(){
  try {
    if(bgOscillator){ bgOscillator.stop(); bgOscillator.disconnect(); bgOscillator = null; }
    if(bgGain){ bgGain.disconnect(); bgGain = null; }
    if(bgAudioCtx){ bgAudioCtx.close(); bgAudioCtx = null; }
  } catch(e){}
}

// Resume suspended AudioContext when page becomes visible again
document.addEventListener("visibilitychange", ()=>{
  if(document.visibilityState === "visible" && bgAudioCtx && bgAudioCtx.state === "suspended"){
    bgAudioCtx.resume().catch(()=>{});
  }
});

// ── Layer 2: Service Worker keepalive ping ────────────────────────────
let swKeepaliveInterval = null;

function startSwKeepalive(){
  if(swKeepaliveInterval) return;
  swKeepaliveInterval = setInterval(async ()=>{
    if(audio.paused){ stopSwKeepalive(); return; }
    if(!navigator.serviceWorker?.controller) return;
    const mc = new MessageChannel();
    navigator.serviceWorker.controller.postMessage({ type:"KEEPALIVE" }, [mc.port2]);
  }, 20000);
}
function stopSwKeepalive(){
  clearInterval(swKeepaliveInterval);
  swKeepaliveInterval = null;
}

// ── Layer 3: Watchdog — catch stuck playback ──────────────────────────────
// If audio.ended fired but next() didn't run (throttled JS at that
// exact moment), this catches it and forces the skip within 3 s.
let watchdogInterval = null;
let lastKnownTime    = -1;
let stuckCount       = 0;

function startWatchdog(){
  if(watchdogInterval) return;
  watchdogInterval = setInterval(()=>{
    if(audio.paused) return;
    // Song is at/past its end but hasn't advanced
    if(audio.duration > 0 && audio.currentTime >= audio.duration - 0.3){
      stuckCount++;
      if(stuckCount >= 1){ stuckCount = 0; next(); }
      return;
    }
    // Time is frozen while supposedly playing (stall/buffer)
    if(audio.currentTime === lastKnownTime && audio.readyState >= 3){
      stuckCount++;
      if(stuckCount >= 3){ stuckCount = 0; audio.play().catch(()=>{ next(); }); }
    } else {
      stuckCount = 0;
    }
    lastKnownTime = audio.currentTime;
  }, 3000);
}
function stopWatchdog(){
  clearInterval(watchdogInterval);
  watchdogInterval = null;
  lastKnownTime = -1;
  stuckCount = 0;
}

// ── Wire all three layers to audio events ──────────────────────────────
audio.addEventListener("play", ()=>{
  startSilentAudio();
  startSwKeepalive();
  startWatchdog();
});
audio.addEventListener("pause", ()=>{
  stopSwKeepalive();
  stopWatchdog();
  // Brief delay before stopping silent audio — in case user quickly resumes
  setTimeout(()=>{ if(audio.paused) stopSilentAudio(); }, 5000);
});
audio.addEventListener("ended", ()=>{
  stopSwKeepalive();
  stopWatchdog();
});

/* ── Handle audio files shared from other apps ──
   When user taps Share → Beast Player in Android, the SW intercepts
   the POST, stores file data temporarily, then redirects to the app.
   On load we ask the SW "any pending shared files?" and import them. */
async function checkPendingSharedFiles(){
  if(!("serviceWorker" in navigator) || !navigator.serviceWorker.controller) return;
  // Ask the SW if there are any pending shared files waiting
  const mc = new MessageChannel();
  navigator.serviceWorker.controller.postMessage({ type: "GET_SHARED_FILES" }, [mc.port2]);
  mc.port1.onmessage = async event => {
    const files = event.data?.files;
    if(!files || !files.length) return;
    await importSharedFiles(files);
  };
}

async function importSharedFiles(incoming){
  if(!incoming.length) return;
  const tx = db.transaction(["songs","playlists"],"readwrite");
  const sStore = tx.objectStore("songs");
  const pStore = tx.objectStore("playlists");
  let added = 0;
  pStore.get("all").onsuccess = e => {
    const all = e.target.result;
    incoming.forEach(f => {
      const blob = new Blob([f.buffer], { type: f.type || "audio/mpeg" });
      const file = new File([blob], f.name, { type: f.type || "audio/mpeg" });
      const id = crypto.randomUUID();
      sStore.put({ id, name: f.name, blob: file, duration: 0 });
      all.songIds.push(id);
      added++;
    });
    pStore.put(all);
  };
  tx.oncomplete = ()=>{
    loadAll();
    toast(`Added ${added} shared song${added!==1?"s":""}`);
  };
}

// Also listen for real-time postMessage (when app is already open)
if("serviceWorker" in navigator){
  navigator.serviceWorker.addEventListener("message", async event => {
    if(event.data?.type === "SHARED_AUDIO_FILES"){
      await importSharedFiles(event.data.files || []);
    }
  });
}

// Check for pending files shortly after init (SW needs a moment to be ready)
setTimeout(checkPendingSharedFiles, 1000);
</script>
</body>
</html>
